<?xml version="1.0" encoding="utf-8"?>


<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="zh-hant">
    <title type="text">illumination</title>
    <subtitle type="html">Illumination | 這是Mingxian的博客, 分享了生活和技术的点点滴滴</subtitle>
    <updated>2024-08-12T21:25:41&#43;08:00</updated>
    <id>http://localhost:1313/</id>
    <link rel="alternate" type="text/html" href="http://localhost:1313/" />
    <link rel="self" type="application/atom&#43;xml" href="http://localhost:1313/atom.xml" />
    <author>
            <name>Mingxian</name>
            <uri>http://localhost:1313/</uri>
            
                <email>yangmingxian2015@gmail.com</email>
            </author>
    <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights>
    <generator uri="https://gohugo.io/" version="0.131.0">Hugo</generator>
        <entry>
            <title type="text">Aloha Mingxian</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/life/hello-mingxian/" />
            <id>http://localhost:1313/life/hello-mingxian/</id>
            <updated>2024-08-12T17:15:59&#43;08:00</updated>
            <published>2024-08-11T23:47:02&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html"></summary>
            
                <content type="html">&lt;!-- [^1]![1921.jpg](/images/1921.jpg) --&gt;
&lt;hr&gt;
&lt;!-- [^1]: 截图自 https://www.youtube.com/watch?v=fdM7KtLqcPE --&gt;</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/life/" term="life\" label="life\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/aphorism/" term="aphorism" label="aphorism" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发 移动端热更</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/game-development-mobile-hot-update/" />
            <id>http://localhost:1313/tech/game-development-mobile-hot-update/</id>
            <updated>2024-08-11T10:51:20&#43;08:00</updated>
            <published>2024-07-25T10:27:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">独立开发的时候有很长一段时间都在前面游戏玩法的设计，能撑到想要上线，并且需要热更维护……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;独立开发的时候有很长一段时间都在前面游戏玩法的设计，能撑到想要上线，并且需要热更维护的开发者少之又少。如何优雅的解决热更新问题似乎是一种甜蜜的烦恼。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本篇文章写于2023年10月底，在游戏行业，或者更确切一点Unity游戏开发行业，几乎清一色你会发现所有的招聘，对面试者的要求总会有这么一项：熟练掌握 Lua。Lua可以说是Unity开发行业的必备技能，他是众多热更方案中最为成熟的。AssetBundle + Lua 似乎成为了行业的通用答案，可惜，这篇文章我不讲Lua，我想学的是一个我认为更简洁优雅的方案 HybirdCLR + Addressables.&lt;/p&gt;
&lt;h2 id=&#34;代码热更&#34;&gt;代码热更&lt;/h2&gt;
&lt;h3 id=&#34;lua&#34;&gt;Lua&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;Lua 系热更&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Lua并非专门为热更开发的语言，Lua是由C语言编写的脚本语言，体积小巧非常精简，如果你有C/C++的基础，便可以急速上手。和Python一样，它属于解释型语言，不需要预编译或者是动态解析，它很适合作一种“胶水语言”用来胶合其他语言框架。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;所以Lua体积小巧：不会热更项目的打包体积造成很大的影响。&lt;/li&gt;
&lt;li&gt;性能上表现良好：虽然无法做到原生C#的性能，但对于资源热更脚本来说也没什么问题。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两点优势使得Lua似乎变得很适合做热更中间件。(其实世界上有很多语言都适合做热更，只是由于当时时代的资源倾斜，使得某一项技术得到青睐，进而雪球越滚越大)&lt;/p&gt;
&lt;p&gt;比如Pyhton也适合做热更语言，而且有很多服务器端会使用Python，并且2023年AI的崛起，Python无疑是当下最为流行的语言。那为啥没人用Python？我认为原因有很多：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在Lua没有登上Unity热更宝座之前，其他引擎例如Cocos，CryEngine等都支持Lua更新，甚至连大名鼎鼎的魔兽世界也使用Lua作为热更语言，这无疑肯定了Lua在热更新领域的地位。会Lua热更的程序员似乎更吃香一些。当然，直到现在也是，你不会Lua，大概率无法进入到一个技术栈固定下来的团队 (但是追求创新和探索的团队并不会在意你会不会Lua)。&lt;/li&gt;
&lt;li&gt;以前的游戏大部分是PC端游，语言除了Unity引擎使用的C#/JS外，绝大多数是C/C++，所以通用的服务器脚本也是Lua为主。在C家族看来，Python是个优雅的异类。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;Lua 与 HybirdCLR&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;那么为啥我不学Lua呢，我对比了 HybirdCLR 的方案，还是觉得Lua有一些地方有局限性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;语言使用： Lua使用的就是Lua语言，热更新的Lua代码通过资源更新的方式下载到包中，程序加载Lua代码并交给Lua虚拟机执行；HybirdCLR热更不需要额外使用其他语言，写好你的C#就行，HybirdCLR 拓展了il2cpp，使得可以通过动态加载dll来执行更新。&lt;/li&gt;
&lt;li&gt;热更范围：Lua开发的所有脚本都可以热更，C#开发的代码可以通过提前的hotfix来做热更补丁，但是你无法预判哪些代码需要进行热更，或者是打标记之后管理上会增加额外的工作; HybirdCLR 的更新范围几乎没有限制，唯一需要注意的是，你需要将需要热更代码所在的程序集装载到il2cpp，然后正常打包，到时候直接替换dll即可，基本上没有不能热更的内容。&lt;/li&gt;
&lt;li&gt;新旧版本性能：Lua需要执行热更改的解释型Lua脚本实现数据或是代码的更新；HybirdCLR 在热更前后，执行的代码还是 native 的原生代码，相当于重新打了一次包编译得到的结果。&lt;/li&gt;
&lt;li&gt;使用便捷性：Lua我就不讲了，需要Lua和C#的互相调用；HybirdCLR 需要添加热更程序集，然后直接修改代码即可。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以说是，HybirdCLR在每方面都优于xLua的方案。只不过因为现有项目的技术栈已经再用Lua了，以及团队中的人更熟悉Lua，学习新的HybirdCLR可能并不如Lua。&lt;/p&gt;
&lt;h3 id=&#34;hybirdclr&#34;&gt;HybirdCLR&lt;/h3&gt;
&lt;p&gt;在介绍HybirdCLR之前，我们需要知道Unity的后端编译的知识。Unity 有 2 种类型的后端: &lt;strong&gt;Mono&lt;/strong&gt; 与 &lt;strong&gt;il2cpp&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在介绍Mono和il2cpp之前，我们需要知道什么是 AOT 和 JIT 编译：
&lt;strong&gt;AOT（Ahead of Time）&lt;/strong&gt;，它将代码在程序运行之前编译成机器码。在Unity中，AOT编译器将C#代码转换为本机机器码，以便在目标平台上直接执行。这种方式可以提高代码的执行效率，因为代码已经被编译成机器码，无需在运行时进行解释和即时编译。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;JIT（Just-in-Time）&lt;/strong&gt;，它在程序运行时将代码动态地编译成机器码。在Unity中，JIT编译器将 IL（Intermediate Language）代码转换为机器码。IL代码是在C#代码编译为中间表示后的形式，它包含了程序的逻辑和结构，但还没有被直接编译成机器码。JIT编译器在程序运行时根据需要将IL代码编译成机器码，并执行编译后的代码。&lt;/p&gt;
&lt;p&gt;那么 HybirdCLR 是如何做热更的？&lt;/p&gt;
&lt;p&gt;在Unity中，默认情况下，Mono运行时使用JIT编译器来执行C#代码。然而，Unity也提供了AOT编译的选项，原始il2cpp相当于只有 AOT 的 Mono，而HybridCLR则给il2cpp新增了原生的interpreter模块，使得il2cpp变成一个有mono功能的 JIT，原生（即通过System.Reflection.Assembly.Load）支持动态加载dll.&lt;/p&gt;
&lt;p&gt;所以呢？&lt;/p&gt;
&lt;p&gt;所以我们使用 HybirdCLR 的时候，做热更的时候，你就直接改C#代码就行了。&lt;/p&gt;
&lt;p&gt;吹了很久 HybirdCLR，现在说一说它的局限性：
首先是官方提供的不支持的特性(其实一般情况下这些特性遇不到，或者是可以想办法绕开)&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;CLR&#34; src=&#34;CLR.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;还有使用上需要注意的：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;只可以使用il2cpp，大型项目的打包会很耗时&lt;/li&gt;
&lt;li&gt;对于需要热更新的代码应该拆分为独立的程序集，才能方便地热更新&lt;/li&gt;
&lt;li&gt;挂载热更新脚本的资源（场景或prefab）必须打包成ab，从ab包中实例化资源，才能正确还原脚本(在实例化资源前先加载热更新dll)；如果将热更新脚本挂载到Resources等随主包的资源上，会发生scripting missing的错误&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;资源热更&#34;&gt;资源热更&lt;/h2&gt;
&lt;h3 id=&#34;assetbundle&#34;&gt;AssetBundle&lt;/h3&gt;
&lt;p&gt;&lt;strong&gt;AssetBundle&lt;/strong&gt; 是一个存档文件，包含可在运行时由 Unity 加载的特定于平台的非代码资源（比如模型、纹理、预制件、音频剪辑甚至整个场景）。 AssetBundle 可以表示彼此之间的依赖关系； 例如，一个 AssetBundle 中的材质可以引用另一个 AssetBundle 中的纹理。 为了提高通过网络传输的效率，可以根据用例要求（LZMA 和 LZ4）选用内置算法选择来压缩 AssetBundle。&lt;/p&gt;
&lt;p&gt;AssetBundle 可用于可下载内容（DLC），减小初始安装大小，加载针对最终用户平台优化的资源，以及减轻运行时内存压力。&lt;/p&gt;
&lt;p&gt;为什么我偏向于Addressable? 一言以蔽之：&lt;/p&gt;
&lt;!-- **Methods of building AssetBundles**：*使用 Addressables 包。这是推荐的、更用户友好的选项，可以直接从 Addressables UI 定义和构建 AssetBundle。它使用相同的基础文件格式和相同的低级 Unity 加载和缓存服务，但间接通过更高级别、更抽象的 API. ——— Unity Documentation v2023.1* --&gt;
&lt;blockquote class=&#34;quote  Unity Documentation v2023.1 https://docs.unity3d.com/cn/2023.1/Manual/AssetBundlesIntro.html&#34;&gt;
        &lt;p&gt;使用 Addressables 包。这是推荐的、更用户友好的选项，可以直接从 Addressables UI 定义和构建 AssetBundle。它使用相同的基础文件格式和相同的低级 Unity 加载和缓存服务，但间接通过更高级别、更抽象的 API.&lt;/p&gt;&lt;/blockquote&gt;
&lt;p&gt;其实可以把Addressable看作AssetBundle的升级版，其实使用方法是很类似的，只是更加便捷了。&lt;br&gt;
&lt;del&gt;我也不明白为啥有很多人还是对AssetBundle有很深的执念，对新技术有一些排斥的心理，似乎也是因为老项目难以迁移或者重构。&lt;/del&gt;&lt;/p&gt;
&lt;h3 id=&#34;addressable&#34;&gt;Addressable&lt;/h3&gt;
&lt;p&gt;首先Addressable其实使用的就是AssetBundle的系统，新增了管理资源的UI界面。&lt;br&gt;
在我看来，他们其实就类似于一个压缩包，只不过这个压缩包&lt;strong&gt;可以寻址&lt;/strong&gt;，可以放在本地应用程序中，也可以&lt;strong&gt;部署到远程分发网络&lt;/strong&gt;上。Unity程序会根据地址访问你打包的资源，那么由于这些压缩包是可以放在网络上的，所以也就提供了&lt;strong&gt;资源热更新&lt;/strong&gt;的可能性。&lt;/p&gt;
&lt;p&gt;如何使用其实也要看项目的需求了，具体的操作方式也比较简单，因为Unity提供了一些UI。文档也比较清楚。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://docs.unity3d.com/Packages/com.unity.addressables@2.0/manual/index.html&#34;&gt;Unity3D Addressables 文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章正在加载中...&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Posts Loading...&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ref&#34;&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://hybridclr.doc.code-philosophy.com/&#34;&gt;https://hybridclr.doc.code-philosophy.com/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">Unity连续碰撞检测</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/unity-continuous-collision-detection/" />
            <id>http://localhost:1313/tech/unity-continuous-collision-detection/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-11-12T14:56:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">Unity有两个内置的碰撞检测方案，基于扫掠的CCD和推断性CCD，其实在大部分的项……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;Unity有两个内置的碰撞检测方案，基于扫掠的CCD和推断性CCD，其实在大部分的项目中，这两种开箱即用的的方法适用于很多情形下的物理模拟了。在你有能力实现自己的物理碰撞系统前，它们无疑是项目最好的选择。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;连续碰撞检测-ccd&#34;&gt;连续碰撞检测 (CCD)&lt;/h2&gt;
&lt;p&gt;看了一些Unity面试的问题，在物理系统中有一个经典的问题就是：如何保证快速运动的物体能够正确的发生碰撞而不是穿透物体。&lt;/p&gt;
&lt;p&gt;有一些Unity开发经验的开发者可能知道这里为什么会出现问题，那就是Unity的物理模拟的帧较长，在每帧更新的时候，因为物体很快，物体在一帧的时间段内的跨度大于被碰撞物体的Collider了。&lt;/p&gt;
&lt;p&gt;有一些无良的教程会让开发者减少每帧的时间，也就是修改Fixed Timestep，单纯的增加模拟的检测密度来检测碰撞，这么做的“好处”就是：项目的资源消耗会成倍增加，你可以更快地淘汰并更换自己的电脑硬件~&lt;br&gt;
那么有什么合理的方法吗：其实有 Hitscan 和 CCD 之类的其他方法，这里我只介绍Unity提供给我们的CCD。&lt;/p&gt;
&lt;p&gt;连续碰撞检测(Continuous collision detection)可确保快速移动的物体与物体碰撞。&lt;/p&gt;
&lt;h3 id=&#34;基于扫掠的-ccd&#34;&gt;基于扫掠的 CCD&lt;/h3&gt;
&lt;p&gt;要使用基于扫掠的 CCD，我们在 Inspector 窗口中选择一个刚体 (RigidBody)，并将 Collision Detection 设置为 Continuous 或 Continuous Dynamic 即可。&lt;/p&gt;
&lt;p&gt;基于扫掠的 CCD 采用撞击时间 (TOI) 算法，通过扫掠对象的前向轨迹来计算对象的潜在碰撞（采用对象的当前速度）。如果沿对象移动方向有接触，该算法会计算撞击时间并移动对象直至达到该时间。代价是需要经历更多的 CPU 周期。&lt;/p&gt;
&lt;p&gt;然而，因为此方法依赖于线性扫掠，所以会忽略物体的角运动。例如，弹球机上的弹球杆固定在一端，围绕一个固定点旋转。弹球杆只做角运动，不做线性运动，因此无法正确撞击小球：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD1.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;已启用 Continuous Dynamic 属性的细杆游戏对象。绕轴心点快速旋转时，此杆不会与球体接触。&lt;/p&gt;
&lt;p&gt;基于扫掠的 CCD 的另一个问题是性能问题。如果附近有大量启用 CCD 的高速对象，CCD 的开销将由于进行额外的扫掠而很快增加，因此物理引擎不得不执行更多的 CCD 子步骤。&lt;/p&gt;
&lt;h3 id=&#34;推断性-ccd&#34;&gt;推断性 CCD&lt;/h3&gt;
&lt;p&gt;要使用推断性 CCD，将 Collision Detection 设置为 Continuous Speculative 即可。&lt;/p&gt;
&lt;p&gt;推断性 CCD 的工作原理是基于对象的线性运动和角运动增大一个对象的粗筛阶段轴对齐最小包围盒 (AABB)。该算法是一种推测性的算法，因为会选取下一物理步骤中的所有潜在触点。然后将所有触点送入解算器，因此可确保满足所有的触点约束，使对象不会穿过任何碰撞体。&lt;/p&gt;
&lt;p&gt;此算法选择所有在下一个物理步骤中潜在的接触点。所有接触点都会被注入到solver中，以确保所有的接触约束都能得到满足，这样物体就不会在碰撞期间引起隧道效应了。&lt;br&gt;
下图显示了一个从t0移动的球，如果它运动路线上没有墙的话，会移动到 t1。通过将它当前位置扩展为AABB，预测算法获得n1和n2两条法线。算法告诉solver预测这些接触点，以使球不会穿过墙面。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;从t0移动的球，如果它运动路线上没有墙的话，会移动到 t1。通过将它当前位置扩展为AABB，预测算法获得n1和n2两条法线。算法告诉solver预测这些接触点，以使球不会穿过墙面。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD3.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;已启用 Continuous Dynamic 属性的细杆游戏对象。绕轴心点快速旋转时，此杆不会与球体接触。&lt;/p&gt;
&lt;p&gt;但是，推测性 CCD 可能会导致幽灵碰撞；在这种碰撞中，对象的运动受到推测性触点的影响，而这是不应发生的。这是因为推测性 CCD 根据最近点算法收集所有潜在触点，所以触点法线不太准确。这通常会使高速对象沿着细分的碰撞特征滑动并跳起来，但不应该这样。例如，下图中，球体从 t0 开始向右水平移动，积分后的预测位置为 t1。扩大后的 AABB 与框形 b0 和 b1 重叠，而 CCD 在 c0 和 c1 产生两个推测性触点。由于推测性 CCD 使用最近点算法来生成触点，&lt;strong&gt;c0&lt;/strong&gt; 具有非常倾斜的法线，因此解算器会将其视作斜坡。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD4.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;解算器认为 c0 处的触点是斜坡，因为最近点算法生成了不准确的触点法线。&lt;/p&gt;
&lt;p&gt;这种非常倾斜的法线导致 t1 在积分后向上跳动，而不是笔直向前移动。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD5.gif&#34;&gt;&lt;/p&gt;
&lt;p&gt;在 c0 处产生的幽灵碰撞导致球体错误地向上跳跃，而不是笔直向前移动&lt;/p&gt;
&lt;p&gt;推测性 CCD 还可能导致发生穿隧，因为只会在碰撞检测阶段计算推测性触点。在触点求解过程中，如果一个对象从解算器获得太多能量，在积分后，其最终位置可能在初始扩大的 AABB 之外。如果在紧邻 AABB 的外部发生碰撞，对象会从右边穿出。&lt;/p&gt;
&lt;p&gt;例如，下图显示了球体从 t0 向左移动，而球杆顺时针旋转。如果球体从撞击中获得太多能量，最终可能离开扩大的 AABB（红点矩形），落在 t1 处。如果在紧邻 AABB 的外部发生碰撞（如下面的蓝色框所示），球体最终可能会从右边穿出。这是因为解算器只计算扩大的 AABB 的内部触点，在求解和积分阶段不会执行碰撞检测。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;SpeculativeCCD&#34; src=&#34;http://localhost:1313/images/2023/SpeculativeCCD6.png&#34;&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">启示录——守望先锋的ECS框架与网络同步</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/revelation-overwatchs-ecs-framework-and-network-synchronization/" />
            <id>http://localhost:1313/tech/revelation-overwatchs-ecs-framework-and-network-synchronization/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-31T10:46:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">《守望先锋》采用 ECS架构，打造了丰富多样的游戏玩法，使得其中的每个英雄都在深度上独……</summary>
            
                <content type="html">&lt;p&gt;&lt;img alt=&#34;同步时钟&#34; src=&#34;http://localhost:1313/images/2023/overwatch_ft.png&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;《守望先锋》采用 ECS架构，打造了丰富多样的游戏玩法，使得其中的每个英雄都在深度上独树一帜而且易于扩展。从托比昂在移动的卡车上建造炮塔，到卢西奥用声波枪攻击敌人，英雄们的技能是独一无二而且复杂的。在2017年的GDC的会议上，暴雪的 Timothy Ford 揭秘了《守望先锋》所使用的游戏技术。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;ecs架构&#34;&gt;ECS架构&lt;/h2&gt;
&lt;h2 id=&#34;网络同步&#34;&gt;网络同步&lt;/h2&gt;
&lt;h3 id=&#34;a-big-deal&#34;&gt;A Big Deal&lt;/h3&gt;
&lt;p&gt;守望先锋的网络同步
如果你想做一个快速反应，对网络同步要求很高的游戏，例如FPS(Overwatch/CS等)、Moba(Lol/Dota)等类型，如果你必须等待服务器告诉你发生了什么，那么玩家将感受到任何东西都不会有及时的响应能力。想象一下那些高Ping的情况，你的操作总会是延后几百毫秒，这也是20多年来的游戏史上，这种类型游戏必须面对的老大难问题。&lt;/p&gt;
&lt;p&gt;想让游戏具有实时响应能力，一个自然而然地解决思路就是去预测玩家的动作，然而游戏中，玩家交给程序的权限只有玩家的输入，在大多数情况下，玩家的输入都在键鼠和手柄上，玩家也不会允许游戏程序去收集玩家的操作信息从而分析玩家的操作习惯(法律应该也不允许未经同意搜集玩家的隐私数据)，所有的一切都只能靠玩家的输入操作。&lt;/p&gt;
&lt;p&gt;网络同步的其中一个目标就是，让游戏中的一切都能迅速响应，快速移动、施放法术、武器投射物等，玩家按下按钮，玩家就会看到立即响应，即便是在高延迟的情况下，玩家也该立刻看到响应。&lt;/p&gt;
&lt;h3 id=&#34;网络同步的副作用&#34;&gt;网络同步的副作用&lt;/h3&gt;
&lt;p&gt;网络同步的副作用是服务器权限以及滞后带来的。你以为你已经进行的操作，其实在服务器端并没有发生。服务器会尝试纠正客户端，不过这是在以不牺牲响应速度为前提的条件下完成的。这听起来有点绕，但是其实如果你玩网游比较多的话，在网络不太给力的时候，还是会经常遇到的。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;比如敌人对你释放了一个缓速并冻结的技能，你正在被缓速，这时候你使用了一个位移技能准备逃离敌人的技能范围，在你的屏幕上会发生以下的事情：&lt;/em&gt;&lt;br&gt;
&lt;em&gt;1. 你的位移技能生效了，你闪出了敌人的缓速冻结的技能范围，你的位移技能释放后进入了冷却CD&lt;/em&gt;&lt;br&gt;
&lt;em&gt;2. 几十或者上百毫秒之后，你突然好像时光回溯一样，你回到了之前的位置，敌人正在向你释放缓速冻结技能，只不过这一次的版本是你并没有及时地按下闪避技能，而且你发现你的闪避技能也恢复到了释放之前的Ready状态&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;其实这里的第一个过程是没有同步到服务器的，所以网络同步对你(也就是客户端进行了矫正)，就会发生2中的情况。&lt;/p&gt;
&lt;p&gt;当然这里的副作用是很难解决的，在大多数情况下，只要你的网络状态没有很大的波动，这种副作用带来的矫正发生的几率是很小的。不过也正是网络同步使得多人游戏的游玩正确性得到了保障。&lt;/p&gt;
&lt;h3 id=&#34;同步时钟&#34;&gt;同步时钟&lt;/h3&gt;
&lt;p&gt;《守望先锋》的确定性模拟依赖于&lt;strong&gt;同步时钟&lt;/strong&gt;，&lt;strong&gt;FixedUpdate&lt;/strong&gt;和&lt;strong&gt;量化的命令帧&lt;/strong&gt;。客户端和服务器都在同步时钟上运行，并且在一个固定的命令帧中执行。在常规的游戏中，命令帧大概是16ms，在竞技比赛中，命令帧的长度是7ms，其实这相当于60Hz和144Hz的刷新率所对应的时间。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;最近正好要换一个电脑显示器，看了很多高刷新率的有的刷新率甚至支持高达360Hz的屏幕，那么问题来了：屏幕刷新速度很快，但是网络同步刷新很慢，电竞上面鼓吹的追求极限高刷新率，有用吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;让我们看一下《守望先锋》的同步时钟是如何做的，下面是同步时钟的演示图：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;同步时钟&#34; src=&#34;http://localhost:1313/images/2023/clock.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;上面的客户端(黄色部分)不断地产生新的输入指令，这些指令会在很短的时间内传入服务器(下面的蓝色部分)，从图中我们可以看到，客户端永远比服务器快Buffer+Half RTT的时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Buffer：大约16ms&lt;/li&gt;
&lt;li&gt;RTT：网络上数据传送的时间和处理的时间，可以认为是Ping的时间延迟+处理的时间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在Timothy的举例中，RTT的时间大约是160ms，也就是说玩家的操作指令发出后，指令会用80ms传送到服务器，然后再加上16ms的缓冲时间(也就是每更新帧的长度)，也就是说客户端的时间要比服务器的时间快80+16ms。&lt;br&gt;
请注意，这里的96ms并不是游玩过程中的延迟，而是服务器和客户端之间同步时钟的距离。在游玩过程中你所需要注意的延迟仅仅只是那16ms的更新帧的长度。这也就解释了为什么你在玩一些游戏的时候，游戏的延迟总是会保持在15-16ms，或是更快一些的6-7ms&lt;/p&gt;
&lt;p&gt;那么回到刚才的问题：高刷的屏幕到底有用吗，一般游戏的更新帧区间不会小于7ms，也就是144Hz，我的看法是，在当前的环境下，屏幕的刷新率只会影响到你客户端(你的屏幕)所看到的内容的更新速度，也就是一些更加连贯的插值动画，对你的输入操作没有影响。当然这仅限于游戏的同步时钟是FixedUpdate是144Hz的情况，如果其他游戏的同步速率更快，那可能就是另外一种情况了。总的来说是高刷显示器有用，但用处不大，起码对于《守望先锋》来说是用处不大的。&lt;/p&gt;
&lt;p&gt;让我们来看一下网络同步中的错误预判，下图是玩家由跑动指令变为空闲站立指令的转变：&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;同步时钟2&#34; src=&#34;http://localhost:1313/images/2023/clock2.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;左图中客户端不断地接收用户的run指令，在某一帧指令变成Idle，在服务器接收到idle指令并将idle指令发回客户端之前，客户端的角色状态一直是跑动(左图中紫色部分)，在客户端接收到服务器的idle指令以后，很不幸的是，客户端的角色跑动状态(左图中紫色部分)是错误的预测，那么客户端就会立刻回滚，也就是服务器纠正了客户端的行为，将客户端的角色跑动状态(左图中紫色部分)纠正为右图的Idle状态。这时候就是我在上文提到的&lt;strong&gt;网络同步的副作用&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&#34;网络问题&#34;&gt;网络问题&lt;/h3&gt;
&lt;p&gt;众所周知，网络连接不会一直稳定可靠，有时候网络的不稳定和丢包会导致网络同步出现问题，所以这里要讲一下守望先锋是如何处理这方面的问题的。&lt;/p&gt;
&lt;p&gt;守望先锋使用的是UDP传输，但是暴雪增加了一层自定义的可选项用来将UDP变得更可靠。&lt;/p&gt;
&lt;p&gt;客户端的输入在某些情况下不会传输到服务器，这里暴雪的服务器会尝试保留一个缓冲区，这个缓冲区就是玩家没有输入的区间。这里的缓冲区应当被设计的尽量小，以保持游戏的响应速度，如果服务器耗尽了缓冲区，也就是在缓冲区间仍然没有成功得到玩家的输入的数据报文，那么服务器就只能替玩家“预测”输入指令了，也就是会重复玩家的最后一个输入。当正确的输入指令到达后，服务器会尝试协调这些指令，然后模拟出正确理应发生的内容以纠正自己的错误预测并同步发送给客户端。&lt;/p&gt;
&lt;p&gt;这里会发生一个比较难以解释的问题，因为服务器并不总是能正确“预测玩家”的输入，暴雪的服务器有一个很复杂的机制，它可以检测到玩家的输入中断，当服务器收不到玩家的输入指令，客户端会加快帧同步速度，在一般情况下的帧长度大概是16ms(60Hz上文提到的)，这时候客户端会加快帧速率，比如15.2ms,而服务器保持在16ms,这为服务器提供了更大的输入缓冲区，同时也加快了检测玩家输入的帧。这样一举两得的技术对网络游戏中遇到的网络延迟、抖动、丢包提供了一个很好的解决方案。&lt;/p&gt;
&lt;p&gt;其实服务器要做的更为复杂和巧妙，我这里只是一言以蔽之，感兴趣的可以参考GDC的开发者大会。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;网络同步中...&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;文章正在加载...&lt;/strong&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发的Tips</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/tips-about-game-design/" />
            <id>http://localhost:1313/tech/tips-about-game-design/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-29T19:19:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">对基础知识的掌握比较重要，有时候工作或是切实开发几年，脱离了基础知识，等到参加一些注……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;对基础知识的掌握比较重要，有时候工作或是切实开发几年，脱离了基础知识，等到参加一些注重基础的面试时，啥也不会了。这里会总结一下游戏工程的基石；开发也中很多小小不言的问题，也会聚沙成塔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;程序上的技巧&#34;&gt;程序上的技巧&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;List的末尾元素 list[^-1]&lt;/p&gt;
&lt;p&gt;在C#中，list[^-1] 是一种从列表（List）的末尾开始索引的新语法。这种语法是C# 8.0引入的一项特性，称为“范围索引”（range indexing）。&lt;/p&gt;
&lt;p&gt;通过使用 [^-1]，可以方便地访问列表中的最后一个元素。它等效于使用索引 list[list.Count - 1] 来获取列表的最后一个元素。&lt;/p&gt;
&lt;p&gt;以下是一个示例，展示了如何使用 [^-1] 来获取列表的最后一个元素：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numbers&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;List&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;2&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;3&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;4&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;};&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;lastNumber&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;numbers&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[^-&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;];&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;n&#34;&gt;Console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;WriteLine&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;lastNumber&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;  &lt;span class=&#34;c1&#34;&gt;// 输出: 5&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;范围索引还支持其他语法，例如使用 [^2] 来获取倒数第二个元素，或使用 [^3..^1] 来获取倒数第三个到倒数第一个元素的范围。&lt;/p&gt;
&lt;p&gt;需要注意的是，范围索引仅适用于支持索引操作的类型，如数组和实现了索引器的集合类型（如 List&lt;T&gt;）。如果尝试在不支持索引操作的类型上使用范围索引，将导致编译错误。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&#34;游戏中的欺骗&#34;&gt;游戏中的“欺骗”&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发基础 性能优化</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/game-development-basics-performance-optimization/" />
            <id>http://localhost:1313/tech/game-development-basics-performance-optimization/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-26T10:55:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">以 Unity3D 为例，整理了一些性能优化的主要内容和知识点。抛开 Unity 性能优化的方向是类似的，主要内……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;以 Unity3D 为例，整理了一些性能优化的主要内容和知识点。抛开 Unity 性能优化的方向是类似的，主要内容无非是CPU/GPU/内存/包体积等几个大方向的优化，道理是相通的，知识是可以迁移的，希望能对游戏领域的小伙伴有所帮助。文章部分正在整理和汇总中，格式和内容还有不完善，请见谅。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;drawcall&#34;&gt;DrawCall&lt;/h2&gt;
&lt;p&gt;Drawcall（绘制调用）是指在图形渲染中，向图形API（如OpenGL或DirectX）发送绘制命令的操作。每次绘制调用都会告诉图形API如何绘制一个或多个图形对象（如三角形、矩形等），包括顶点数据、纹理信息、着色器等。
在游戏或图形应用中，绘制调用的次数对性能有较大影响。每个绘制调用都会引起CPU和GPU之间的通信开销，而通信开销是比较昂贵的。&lt;br&gt;
比如你要买水果，一次袋子里只装一个拿回家，往返20次；还是一次装20个只往返一次呢。也许你觉得对于计算机巨大的算力来说这不算什么，但是实际情况是，这种类似的计算每秒要计算上千万次。尽量减少不必要的计算会导致累积的结果发生质的变化。因此，减少绘制调用的次数以提高性能是一个重要且常见的优化手段。&lt;/p&gt;
&lt;h3 id=&#34;drawcall的优化&#34;&gt;DrawCall的优化&lt;/h3&gt;
&lt;p&gt;在Unity中，有以下几种常见优化Drawcall的方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;批量处理（Batching）：将多个相同材质、纹理、渲染模式等属性的图形对象合并到一个Drawcall中，减少CPU-GPU通信消耗。Unity有两种批处理的方式：&lt;strong&gt;静态合批&lt;/strong&gt; 和 &lt;strong&gt;动态合批&lt;/strong&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;静态合批：适用于不会频繁移动或者修改的静态物体，如静态环境、地形等。
- 合并方式：在Build阶段，Unity会将静态物体合并成一个大Mesh，使用共享的材质，以减少Drawcall&lt;/li&gt;
&lt;li&gt;动态合批：适用于需要频繁移动或者修改的动态物体，如粒子效果、角色等。
- 合并方式：在运行时Unity自动把每一帧画面里符合条件*的多个模型网格合并为一个，再传递给GPU&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;合并纹理（Texture Atlasing）：将多个小纹理合并为一个大纹理图集，减少绘制调用和纹理切换。可以使用TexturePacker等工具来自动合并纹理；可以使用Sprite Atlas将Sprites打包成同一图集。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少不必要的渲染状态切换：避免在绘制调用之间频繁切换渲染状态，如材质、着色器等。可以通过合并材质、使用相同的着色器等方式来减少状态切换。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;GPU Instancing：利用硬件实例化技术，通过复制几何体和使用实例化数据来减少绘制调用，对于使用同一网格 和 同一材质的物体们，它使用少量的渲染调用(DrawCall)，渲染同一网格的多个副本。有Unity自动和手动两种方式。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;减少透明物体的数量：透明物体需要额外的渲染步骤，因此数量过多会导致 Draw Call 增加。可以通过使用不透明物体、使用 Alpha Test 等方式来减少透明物体的数量。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;!-- ### 批处理
#### 静态批处理
##### 原理
态批处理是将多个静态物体合并为一个网格进行渲染，以减少 Draw Call 的数量。在静态批处理中，首先需要将多个静态物体的网格数据合并为一个大的网格数据，然后将该网格数据传递给渲染引擎进行绘制。通过将多个静态物体合并为一个网格进行渲染，可以避免重复设置渲染状态和切换渲染资源，从而提高渲染效率。
#### 

#### 动态批处理 --&gt;
&lt;blockquote&gt;
&lt;p&gt;只有当动态批处理产生的CPU开销小于DrawCall的开销，动态批处理才具有优化性能的效果。而在如今的电子设备上，动态批处理产生的CPU开销反而有可能大于DrawCall的开销，影响性能&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;ugui的优化&#34;&gt;UGUI的优化&lt;/h3&gt;
&lt;p&gt;Unity中UI优化的主要方向是减少Drawcall，主要的优化思路与上文类似，只是实现手段的不同。
简要的说一下以上提到的一些UI减少Drawcall的实现方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用UI Image组件和Sprite Atlas&lt;/li&gt;
&lt;li&gt;避免使用大量的透明材质&lt;/li&gt;
&lt;li&gt;使用合适的排序层&lt;/li&gt;
&lt;li&gt;禁用不需要的Raycast Target&lt;/li&gt;
&lt;li&gt;使用合适的像素适应设置&lt;/li&gt;
&lt;li&gt;使用合适的UI Element组件，例如Image和rawImage&lt;/li&gt;
&lt;li&gt;避免使用过多的动态效果&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;除此之外还有进阶的优化思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;UI的动静分离&lt;/strong&gt;&lt;br&gt;
UGUI构建后会合并网格。当UI元素移动或者Transform时，需要重新合批，导致同一批中的其他内容需要再次构建。因此将会动的UI元素放入专门的画板中，将静止的UI元素留在另一个画板上，这样在重构动态UI的时候就不会影响到静态UI，减少了CPU重绘和合并的消耗。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;拆分过重的UI&lt;/strong&gt;&lt;br&gt;
一个部件的UI元素过多，层级过深，会导致实例化或者是销毁的成本增加，也会造成搜索效率的骤减，并且难以管理。所以拆分与重组相关UI也是优化的方向。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI预加载&lt;/strong&gt;&lt;br&gt;
UI实例化时，期间会有网格的合并、组件初始化、渲染初始化、图片加载、界面逻辑初始化等，会消耗大量的CPU。可以考虑负载均衡的预载时机。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;UI贴图设置的优化&lt;/strong&gt;
&lt;ul&gt;
&lt;li&gt;是否需要Alpha通道。需要则打开，不需要则关闭。&lt;/li&gt;
&lt;li&gt;是否需要进行2次方大小修正。对于UI贴图来头像这类Icon基本上都是2次方大小。&lt;/li&gt;
&lt;li&gt;去除读、写权限。这里通勾选的话，会使贴图在内存中存储两份方便脚本读写，导致比不勾选的时候内存增加一倍。&lt;/li&gt;
&lt;li&gt;去除Mipmap。Mipmap是对3D远近视觉的优化，通过生成不同大小的图，在摄像头远离物体时因为不需要高清的图片而使用Mipmap生成的小而模糊的贴图，从而减轻GPU的负担。但2D中没有远近之分，不需要这个功能，使用的话反而会导致内存和磁盘空间加大，UI看起来模糊。&lt;/li&gt;
&lt;li&gt;选择压缩方式。压缩主要时为了降低内存的消耗、加载时的消耗，降低CPU与GPU之间的带宽消耗，在保证清晰度的前提下，应尽可能的选择一个压缩方式来优化内存和包体&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;blockquote&gt;
&lt;p&gt;这里只列举了部分优化思路，还有很多其他思路，在这里先不一一列举了，有时间再添加别的。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;内存优化&#34;&gt;内存优化&lt;/h2&gt;
&lt;p&gt;Unity的内存主要分为三大类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;托管内存：主要是托管堆或GC管理的内存&lt;/li&gt;
&lt;li&gt;非托管内存：C#交互使用的内存，可以与Unity Collection命名空间和package结合使用，不包含GC内存&lt;/li&gt;
&lt;li&gt;Native内存：Unity运行引擎使用的C++部分的内存&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意到的是，以上是Unity使用的内存，如果是Unity应用，应用程序还会占用GPU显存(移动端的内存),程序框架占用的内存，第三方库使用的内存和系统内存。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;heading&#34;&gt;&lt;/h3&gt;
&lt;h2 id=&#34;代码架构优化&#34;&gt;代码架构优化&lt;/h2&gt;
&lt;h3 id=&#34;ecs架构&#34;&gt;ECS架构&lt;/h3&gt;
&lt;p&gt;ECS（Entity-Component-System）是一种用于游戏开发的架构模式。它的核心思想是将游戏中的实体(Entity)、组件(Component)和系统(System)分离，以提供更高效和可扩展的编程模型。个人认为ECS其实就是为了&lt;strong&gt;代码解耦&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;在 ECS 架构中，游戏对象（实体）被分解为包含不同功能的组件。每个组件只包含描述实体的某个特定方面的数据，而不包含任何行为。例如，一个游戏角色实体可以包含渲染组件、动画组件和碰撞组件等。实体和组件时一对多的关系，实体有怎样的功能取决于其所拥有的组件，再游戏中Runtime地进行组件的添加/修改/删除就可以Runtime地改变实体的行为。&lt;/p&gt;
&lt;p&gt;组件和Unity的Component概念相似，但是这里的组件不包含任何行为，组件的行为是通过一些独立的系统来处理的，这又和Unity中继承式的组件结构又完全不同了。这些独立的系统负责对具有相似组件的实体进行操作和处理。系统通过访问组件的数据进行逻辑处理，例如更新位置、计算物理碰撞等。每个系统只关注和处理特定的组件，而与其他组件和系统无关。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;ECS 在2017的 GDC 上由暴雪守望先锋的开发者分享出来并得到大规模关注(并非暴雪提出此架构)，GDC永远是游戏开发者的知识盛会，无数游戏开发的创意、结构、设计都由世界各地的开发者由此分享出来。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;video src=&#34;https://www.youtube.com/watch?v=W3aieHjyNvw&#34; controls&gt;&lt;/video&gt;&lt;/p&gt;
  &lt;!-- https://www.youtube.com/watch?v=zrIY0eIyqmI --&gt;
&lt;h4 id=&#34;ecs的优势&#34;&gt;ECS的优势&lt;/h4&gt;
&lt;p&gt;ECS组件的行为通过系统来处理。系统是一些独立的模块，负责对具有相似组件的实体进行操作和处理。系统通过访问组件的数据进行逻辑处理，例如更新位置、计算物理碰撞等。每个系统只关注和处理特定的组件，而与其他组件和系统无关&lt;/p&gt;
&lt;p&gt;所以ECS结构有以下优势：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;扩展性&lt;/strong&gt;：ECS的行为逻辑是数据驱动的，因此实体的行为和属性数据是分离的，使得可以实现更为灵活的组合和代码扩展，降低代码耦合度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;性能优化&lt;/strong&gt;：ECS的数据驱动逻辑可以实现相关对象实体执行行为逻辑而不需要遍历所有的对象。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;那么有哪些模块适合使用ECS呢？&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;游戏对象管理&lt;/strong&gt;：当游戏中有大量的实体，ECS易于处理实体的创建、销毁和更新。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;物理模拟&lt;/strong&gt;：ECS可以用于大规模的物理模拟，例如粒子物理，通过物理组件作为实体的一部分，针对这些组件的物理系统进行更新，可以获得更好的性能。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;碰撞检测&lt;/strong&gt;：和物理模拟类似，ECS可以实现通过独立的系统来处理碰撞检测，例如将每个实体的碰撞组件作为输入，根据需要执行碰撞检测逻辑。这种方式可以提高碰撞检测的效率，特别是当涉及大量实体和复杂碰撞逻辑时。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;AI寻路&lt;/strong&gt;：对于需要处理大量AI代理和路径规划的游戏，ECS架构可以提供更高效的处理方式。通过将AI组件和路径组件与独立的系统结合使用，可以对大量AI代理进行并行化处理&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&#34;unity中的ecs&#34;&gt;Unity中的ECS&lt;/h4&gt;
&lt;p&gt;Unity中可以使用Unity.Entities命名空间来使用ECS的API，需要导入ECS的包：&lt;em&gt;&lt;strong&gt;Entities&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;h5 id=&#34;loading-please-stand-by&#34;&gt;&lt;em&gt;&lt;strong&gt;Loading... Please stand by...&lt;/strong&gt;&lt;/em&gt;&lt;/h5&gt;
&lt;h5 id=&#34;文章正在加载中-&#34;&gt;&lt;em&gt;&lt;strong&gt;文章正在加载中... ...&lt;/strong&gt;&lt;/em&gt;&lt;/h5&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发基础 计算机基础</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/game-development-basics-computer-basics/" />
            <id>http://localhost:1313/tech/game-development-basics-computer-basics/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-22T12:00:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">本篇文章介绍了游戏开发中一些比较基础的知识，内容涉及到了一些计算机网络、计算机组成原……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;本篇文章介绍了游戏开发中一些比较基础的知识，内容涉及到了一些计算机网络、计算机组成原理、设计模式、操作系统的内容，内容覆盖面广，但是其实并不是很深入，明白原理和概念即可。文章作于面试前夕，复习的时候顺便记录一下学习的足迹。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记得第一次面试的时候, 面试的岗位是Unity开发, 面试官第一个问题就是: 你都用过什么设计模式，我一听就觉得，坏了，这个面试官喜欢考八股文，那时候还没看过设计模式，听起来就高大上啊，毫无悬念的不会。后来我去看了一点设计模式，看过之后忍不住感叹一句：就这？我得到了一个观点：设计模式这种东西，既有用也没用。虽然后面写到那我们再说。不过抛开这些来说，一个人真正的能力是基于他的基础知识的，有了基础之后才会知其然知其所以然，只有当你知道这些东西之后，你才有资格评判它们。&lt;/p&gt;
&lt;h2 id=&#34;计算机网络&#34;&gt;计算机网络&lt;/h2&gt;
&lt;h3 id=&#34;网络层次划分&#34;&gt;网络层次划分&lt;/h3&gt;
&lt;p&gt;在计算机网络中，网络层次划分通常指的是OSI模型（开放式系统互联模型）或TCP/IP模型中的网络层次结构。
现代互联网大多使用更简单的 TCP/IP 模型。但是OSI七层模型为网络的标准层次划分，在介绍TCP/IP模型之前还是先了解一下OSI吧。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;OSI模型&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;层&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;职责&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;信息格式&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;设备或协议&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;7&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;人机交互层，应用可以访问网络服务&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;SMTP&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;6&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;表示层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;确保数据为可用格式，数据加密等&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;JPEG, MPEG, GIF&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;5&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;会话层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;维护连接、控制端口和会话&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Message&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Gateway&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;运输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;根据协议传输数据(TCP&amp;amp;UDP)&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Segment&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Firewall&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;决定数据传送的物理路径&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Packet&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Router&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;定义了网络上数据的格式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Frame&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Switch, Bridge&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;物理层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;在物理设备间传输生数据流&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Bits&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Hub, Repeater, Modem, Cables&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;&lt;strong&gt;TCP/IP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;OSI 第 5、6、7 层在 TCP/IP 中合并为一个应用层。OSI 第 1 层、第 2 层在 TCP/IP 中合并为一个网络访问层，但 TCP/IP 不负责排序和确认功能，而是将这些功能留给底层传输层。&lt;/p&gt;
&lt;p&gt;&lt;img alt=&#34;OSI和TCP/IP的结构&#34; src=&#34;http://localhost:1313/images/2023/OSI-TCP.jpg&#34;&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;层&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;名称&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;职责&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;信息格式&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;4&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;应用层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络应用程序和网络通信的接口&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Message&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;3&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;传输层提供了端到端的数据传输服务&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Segment&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;2&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;网络层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据包的路由和转发&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;数据报&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;1&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;链路层&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;通过物理介质传输数据的规范&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;Frame&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3 id=&#34;tcpip协议和udp协议&#34;&gt;TCP/IP协议和UDP协议&lt;/h3&gt;
&lt;p&gt;重要性不说了。
TCP（Transmission Control Protocol）和UDP（User Datagram Protocol）是计算机网络中两种常用的传输层协议。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;TCP&lt;/strong&gt;是一种面向连接的可靠传输协议。在使用TCP进行通信时，发送方和接收方需要先建立一个连接，然后通过这个连接进行数据的传输。TCP通过序列号和确认机制来保证数据的可靠性，确保数据按照正确的顺序到达目标地点。如果发生数据丢失或损坏，TCP会自动进行重传，直到数据被正确接收。TCP还可以进行拥塞控制，根据网络的情况动态调整数据的发送速率，以避免网络拥塞。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;UDP&lt;/strong&gt;是一种无连接的不可靠传输协议。在使用UDP进行通信时，发送方直接将数据报发送给接收方，而不需要建立连接。UDP不提供数据的可靠性保证和重传机制，因此在传输过程中可能会出现数据丢失或乱序的情况。UDP的优点是传输效率高，适用于对实时性要求较高但对数据可靠性要求不高的应用场景，例如音视频传输和在线游戏中的实时操作&lt;/p&gt;
&lt;h3 id=&#34;tcpip的三次握手&#34;&gt;TCP/IP的三次握手&lt;/h3&gt;
&lt;p&gt;&lt;img alt=&#34;TCP/IP的三次握手&#34; src=&#34;http://localhost:1313/images/2023/tcp.png&#34;&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤1 (SYN)&lt;/strong&gt;：第一步，客户端要与服务器建立连接，因此它发送一个带有SYN（同步序列号）的报文段，告知服务器客户端可能开始通信以及以什么顺序开始通信分段开始的编号&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 2（SYN + ACK）&lt;/strong&gt;：服务器使用设置的 SYN-ACK 信号位来响应客户端请求。确认 (ACK) 表示对收到的数据段的响应，SYN 表示可能以什么序列号开始数据段&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;步骤 3 (ACK)&lt;/strong&gt;：在最后一部分中，客户端确认服务器的响应，并且双方建立可靠的连接，并通过该连接开始实际的数据传输&lt;/p&gt;
&lt;p&gt;其实原理异常简单，我来叙述一遍通俗版：
A想和B互换书籍来看，但是它们之间的快递不是很给力，所以提前约法三章，先尝试交换三次的封面以确保后续的交换不出差错。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;A：你好啊B，我想和你 &lt;font color=&#34;#A7D397&#34;&gt;交换(SYN)&lt;/font&gt; 书籍来看, 我先把《哈利波特》的 &lt;font color=&#34;#00A9FF&#34;&gt;第100章节(seq=100)&lt;/font&gt; 的封面寄给你了。&lt;/li&gt;
&lt;li&gt;B：OK，我可以给你看我的《名侦探柯南》&lt;font color=&#34;#00A9FF&#34;&gt;第200章节(seq=200)&lt;/font&gt;，我已经 &lt;font color=&#34;#E7455F&#34;&gt;收到(ACK)&lt;/font&gt; 你的《哈利波特》的 &lt;font color=&#34;#A7D397&#34;&gt;第100章节(seq=100)&lt;/font&gt; 的封面了，我期待《哈利波特》&lt;font color=&#34;#713ABE&#34;&gt;主体内容(ack=seq+1=100+1)&lt;/font&gt;，让我们 &lt;font color=&#34;#A7D397&#34;&gt;交换(SYN)&lt;/font&gt; 吧&lt;/li&gt;
&lt;li&gt;A: 好的，给你《哈利波特》&lt;font color=&#34;#00A9FF&#34;&gt;主体内容(seq=101)&lt;/font&gt;, 我也 &lt;font color=&#34;#E7455F&#34;&gt;收到(ACK)&lt;/font&gt; 你的《名侦探柯南》&lt;font color=&#34;#00A9FF&#34;&gt;第200章节(seq=200)&lt;/font&gt;, 我也期待你的《哈利波特》&lt;font color=&#34;#713ABE&#34;&gt;主体内容(ack=seq+1=200+1)&lt;/font&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;然后他们就完成连接，后面开始传送数据了。其实理解上并不复杂，只是数据报的数字和指令看起来比较绕而已。如果你还是记不清这些字母，知道它们的英语之后，就会自然而然地理解(请区别缩写和小写)：&lt;/p&gt;
&lt;p&gt;SYN  (Synchronize sequence numbers)  同步序列号
ACK  (Acknowledgment field significant)  确认确认号栏位为有效字段
ack-nowledgment number确认号
seq-uence number  序列号&lt;/p&gt;
&lt;p&gt;为什么不两次握手的原因也很简单，是为了防止网络超时或者波动导致有可能在建立连接之后收到了以前最开始发的指令。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;举个例子：A发了一个SYN_0请求连接B，超时了，然后发送了一个SYN_1,后面所有的过程都顺利进行了，AB连接开始传送数据了。然后这时候最一开始那个SYN_0在网络波动中幸存了下来，传送到了B，这时候B会认为A又重新发起了一个连接请求。所以需要第三次握手。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;无论是所有的一切的核心理念就是：&lt;strong&gt;要在不可靠的信道里面，创建一个可靠的连接&lt;/strong&gt;&lt;/p&gt;
&lt;h3 id=&#34;tcpip的四次挥手&#34;&gt;TCP/IP的四次挥手&lt;/h3&gt;
&lt;p&gt;有了三次握手的知识，其实四次挥手的理解也变得简单了：&lt;/p&gt;
&lt;p&gt;数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，然后客户端主动关闭，服务器被动关闭。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;第一次挥手（FIN）&lt;/strong&gt;：主动关闭方发送一个FIN（Finish）报文段给被动关闭方，表示主动关闭方不会再发送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第二次挥手（ACK）&lt;/strong&gt;：被动关闭方收到FIN报文段后，发送一个确认报文段（ACK）作为响应，表示已收到关闭请求。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第三次挥手（FIN）&lt;/strong&gt;：被动关闭方发送一个FIN报文段给主动关闭方，表示被动关闭方也不会再发送数据。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;第四次挥手（ACK）&lt;/strong&gt;：主动关闭方收到FIN报文段后，发送一个确认报文段（ACK）作为响应，表示已收到关闭请求&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是，四次挥手过程中的ACK确认报文段不一定是立即发送的，可以与其他数据一起发送，也可以延迟发送。这取决于具体的实现和网络条件。&lt;/p&gt;
&lt;p&gt;这里也会有序列号(seq)的参与，限于篇幅就不展开写了，网上的讲解又多又全，远超我这个菜鸡。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;为什么建立连接是三次握手，关闭连接确是四次挥手呢？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在建立连接时，发起方需要向服务方发送请求，并等待服务方的确认，这两个步骤可以合并为一次握手。
而在关闭连接时，由于双方都可能还有未发送完的数据，因此需要进行两次的关闭操作，分别表示发起方和服务方不再发送数据，最后进行一次确认，可以理解是对称的。&lt;/p&gt;
&lt;h3 id=&#34;udp&#34;&gt;UDP&lt;/h3&gt;
&lt;p&gt;UDP提供不可靠的服务并且是无连接的。但是可能产生丢包，所以适用于对实时性要求较高但是对少量丢包并没有太大要求的场景。比如：语音通话，视频直播等。udp还有一个非常重要的应用场景就是隧道网络，VPN就源于此。
主要特点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UDP 是无连接的，即发送数据之前不需要建立连接(发送数据结束时也没有连接可释放)，减少了开销和发送数据之前的时延&lt;/li&gt;
&lt;li&gt;UDP 使用尽最大努力交付，即不保证可靠交付，主机不需要维持复杂的连接状态表&lt;/li&gt;
&lt;li&gt;UDP 是面向报文的，发送方的 UDP 对应用程序交下来的报文，在添加首部后就向下交付 IP 层。UDP 对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界&lt;/li&gt;
&lt;li&gt;UDP 没有拥塞控制，网络出现的拥塞不会使源主机的发送速率降低。这对某些实时应用是很重要的&lt;/li&gt;
&lt;li&gt;UDP 的首部开销小，只有8个字节，比 TCP 的20个字节的首部要短&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我看网上说有的面试官喜欢问如何改进UDP让它变得可靠。&lt;del&gt;你可以回答：用TCP协议呗。简洁利落的回答证明了自己的专业又为面试官节省了时间，何乐而不为呢？XD&lt;/del&gt;&lt;/p&gt;
&lt;p&gt;有一些开源的方案提供了改进的思路(RUDP、RTP、UDT等)&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;应用层协议设计：可以在应用层上设计一种自定义的协议，通过添加确认、重传和序列号等机制来实现可靠性传输。这样的协议可以根据具体的应用需求进行定制，但需要在应用程序中实现相应的逻辑。&lt;/li&gt;
&lt;li&gt;超时与重传：在发送端引入超时和重传机制。发送端在发送数据后启动一个定时器，如果在一定时间内没有收到对应的确认，就认为数据丢失，触发重传机制重新发送数据。接收端可以通过确认消息来指示发送端需要重传的数据。&lt;/li&gt;
&lt;li&gt;确认机制：接收端可以向发送端发送确认消息，表示已成功收到数据。发送端在收到确认消息后才认为数据传输成功，否则会触发重传机制。可以使用累计确认（cumulative acknowledgment）来减少确认消息的数量。&lt;/li&gt;
&lt;li&gt;序列号：在数据包中添加序列号，接收端可以根据序列号对数据进行排序和重组。序列号还可以用于检测重复数据包和丢失数据包。
流量控制：通过控制发送速率和接收端缓冲区大小，可以避免发送过多的数据导致接收端无法及时处理而丢失数据。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;尽管这些改进方法可以提高UDP的可靠性，但它们也会增加传输的延迟和开销。对于对可靠性要求较高的应用场景，考虑使用TCP等已经提供可靠性传输保证的协议可能更为合适。&lt;br&gt;
&lt;del&gt;md，说到底还是TCP那一套。不要妄想自己有实力颠覆网络通信协议，当然如果你能提出并实现KCP那样的网络协议，那你没必要拘泥于这些Useless的八股文，别花时间做一些没用的事情。&lt;/del&gt;&lt;/p&gt;
&lt;!-- 
##在线游戏的通讯 --&gt;
&lt;!-- 
## 计算机组成原理
## 操作系统 --&gt;
&lt;h2 id=&#34;设计模式与吐槽&#34;&gt;设计模式与吐槽&lt;/h2&gt;
&lt;h3 id=&#34;单例模式&#34;&gt;单例模式&lt;/h3&gt;
&lt;p&gt;用于确保一个类只有一个实例，并提供一个全局访问点来访问该实例。在单例模式中，类的实例化过程受到严格控制，使得系统中只有一个实例存在，并且该实例可以被其他对象共享和访问。&lt;/p&gt;
&lt;p&gt;应用场景：
当一个类只需要一个实例来协调操作时，例如线程池、缓存、日志记录器等。
当对资源访问需要控制时，例如数据库连接池。
当希望通过统一的接口管理全局状态时。&lt;/p&gt;
&lt;p&gt;实现方式：
懒汉式单例：在首次访问时创建实例。如果没有线程安全的控制，可能会导致多个实例的创建。
饿汉式单例：在类加载时就创建实例，确保了线程安全。但在某些情况下可能会导致资源浪费，因为实例在整个程序周期内都存在，即使没有被使用。
双重检查锁定（Double-Checked Locking）单例：结合了懒汉式和饿汉式的优势，在首次访问时创建实例，并通过加锁保证线程安全。
静态内部类单例：利用类的初始化锁机制实现延迟加载和线程安全。&lt;/p&gt;
&lt;h3 id=&#34;工厂模式&#34;&gt;工厂模式&lt;/h3&gt;
&lt;p&gt;它提供了一种将对象的实例化过程封装起来的方式。工厂模式通过定义一个共同的接口或基类，然后由具体的工厂类负责创建符合接口或基类定义的对象实例。&lt;/p&gt;
&lt;p&gt;工厂模式通常在以下情况下使用：&lt;/p&gt;
&lt;p&gt;当需要创建复杂对象时，对象的创建过程涉及到多个步骤或依赖关系复杂时，可以使用工厂模式将创建过程封装起来，降低对象的创建复杂度。
当希望通过统一的接口来创建对象，而不暴露具体实现类时，可以使用工厂模式隐藏对象的具体实现。
工厂模式的主要角色包括：&lt;/p&gt;
&lt;p&gt;抽象工厂（Abstract Factory）：定义创建对象的接口，它可以是一个接口或抽象类。
具体工厂（Concrete Factory）：实现抽象工厂中定义的创建对象的方法，返回具体的对象实例。
抽象产品（Abstract Product）：定义工厂创建的对象的接口，可以是一个接口或抽象类。
具体产品（Concrete Product）：实现抽象产品接口的具体对象。&lt;/p&gt;
&lt;p&gt;工厂模式可以根据具体的需求进行扩展和变化，常见的工厂模式包括简单工厂模式、工厂方法模式和抽象工厂模式。
简单工厂模式通过一个工厂类来创建所有的产品对象，根据传入的参数或条件来确定创建哪种具体产品。
工厂方法模式将对象的创建延迟到具体的工厂类中，每个具体工厂类负责创建一个具体产品。
抽象工厂模式提供了一种创建一系列相关或相互依赖对象的接口，每个具体工厂类负责创建一族产品&lt;/p&gt;
&lt;h3 id=&#34;观察者模式&#34;&gt;观察者模式&lt;/h3&gt;
&lt;p&gt;用于在对象之间建立一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都会得到通知并自动更新。&lt;/p&gt;
&lt;p&gt;观察者模式通常在以下情况下使用：&lt;/p&gt;
&lt;p&gt;当一个对象的改变需要通知其他对象，并且不需要知道具体通知哪些对象时，可以使用观察者模式。
当一个对象的改变需要同时改变其他对象的状态，但又希望对象之间解耦，以避免紧密耦合的代码。
观察者模式的主要角色包括：&lt;/p&gt;
&lt;p&gt;主题（Subject）：也称为被观察者或可观察对象，它维护一组观察者对象，并在状态改变时通知观察者。
观察者（Observer）：定义一个更新接口，用于接收主题的通知并进行相应的更新操作。
具体主题（Concrete Subject）：实现主题接口，维护观察者对象的集合，并在状态改变时通知观察者。
具体观察者（Concrete Observer）：实现观察者接口，存储与主题相关的状态，并在接收到通知时进行更新操作。
观察者模式可以实现松耦合的对象之间的交互，使得主题和观察者之间的关系更加灵活和可扩展。当一个系统中的对象之间存在一对多的依赖关系，并且需要在对象状态改变时进行通知和更新时，观&lt;/p&gt;
&lt;h3 id=&#34;吐槽&#34;&gt;吐槽&lt;/h3&gt;
&lt;p&gt;其实如果你写代码时能注意一些解耦和合理代码结构的事情，那么设计模式其实对你来说用处不大。有时候你的代码会无意间遵循设计模式的金科玉律。接下来我举例证明设计模式是没啥用处的。&lt;/p&gt;
&lt;p&gt;我使用Unity3D比较多，拿单例模式来说吧，一般是不是单例模式会用在Unity的一些管理类或者是某些唯一的东西上面，因为我们希望它们是唯一的，并且可以全局的管理一些事情。&lt;/p&gt;
&lt;p&gt;单例模式有两个特性：1. 单例必须仅限于单个实例 2. 实例需要是全局可访问的。&lt;/p&gt;
&lt;p&gt;很合理，而且在简单项目中非常好用。用AudioManager举例，它用于参与全局控制整个游戏的音频逻辑。单例模式允许你不需要在Unity的Inspector里面指定引用，或者是用代码去寻找这个类，你直接访问这种全局实例即可，你可以在任何地方随意访问它们。&lt;/p&gt;
&lt;p&gt;当我们的代码量很大时，单例模式省去了很多类的依赖关系，很不巧的是你需要到处使用它们来传递数据，一开始这种mess并不明显，但是当你有一些团队成员，或是你自己需要处理一段时间之前自己写的代码时，你会发现这些代码慢慢滚雪球变成了屎山。&lt;/p&gt;
&lt;p&gt;并且，在Unity里面，你想使用单例模式，遇到的问题会更多，下面是最普通的一个单例模式的实现：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;GameManager&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;MonoBehaviour&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameManager&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Awake&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;!=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;n&#34;&gt;Destroy&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gameObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;            &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;n&#34;&gt;DontDestroyOnLoad&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;gameObject&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;static&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GameManager&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;GetInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;instance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 其他游戏逻辑代码...&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;在Unity中MonoBehaviour隐藏了构造函数，并使得Instantiate可以实例化它们。大多时候我们都会继承MonoBehaviour，那么我们就需要在Awake中检查实例是不是已经存在了，如果基于MonoBehaviour在创建时存在另一个实例，它必须要Destroy自己。当新场景加载时，DontDestroyOnLoad使得原来的实例保持存在，新场景中如果存在一个实例的话，根据它们在Hierarchy，有可能一个错误的实例被Destroy了。其实局限性有很多。这么来看，设计模式好像是在多此一举。要是真的想用类似的东西，static静态类与静态成员反而是最简洁的答案。&lt;/p&gt;
&lt;p&gt;而类似于工厂模式之类的概念，我只能说，在没有学设计模式之前，我也是那么做的。比如Unity的Pooling就是一个最典型的例子。
又如观察者模式，Unity或者是C#的事件系统不就是这种思路吗，解耦的常规操作而已。往往我们在优化代码结构时，稀里糊涂就遵循了某些设计模式。&lt;/p&gt;
&lt;p&gt;而更多的情况，设计模式只是提供了指导思路，有时候并不能纯粹地使用这些模式，而是需要一些变形或是结合，那么问题来了：经过变化的设计模式，它还是之前的那个设计模式了吗？有时候不能太教条，&lt;strong&gt;设计模式是指导思路，不是一个规范&lt;/strong&gt;。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;文章正在加载中... ...&lt;/strong&gt;&lt;br&gt;
&lt;strong&gt;Loading Posts... ...&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&#34;ref&#34;&gt;&lt;strong&gt;Ref&lt;/strong&gt;&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发基础 图形学基础</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/game-development-basics-graphics-basics/" />
            <id>http://localhost:1313/tech/game-development-basics-graphics-basics/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-21T14:45:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">图形学知识是基础，即便你在使用的游戏引擎已经帮你完成了大多数工作，但是这些基础的概念……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;图形学知识是基础，即便你在使用的游戏引擎已经帮你完成了大多数工作，但是这些基础的概念有助于你对渲染的过程有更好的理解，才会知其所以然。所以趁着复习的机会在这里整理一些必要的知识基础。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;图形管线&#34;&gt;图形管线&lt;/h2&gt;
&lt;h3 id=&#34;图形管线概述&#34;&gt;图形管线概述&lt;/h3&gt;
&lt;p&gt;图形管线，这是绝大多数计算机渲染的基础过程。渲染管线其实并不是一个很高深的名词，也有的人会叫做图形学管线、GPU渲染管线等，只是表示计算机如何把图形图像信息显示到你的屏幕上来这一过程，因为类似于工厂的流水线，所以才叫管线。&lt;/p&gt;
&lt;p&gt;图形管线要把模型转换成屏幕画面的过程，由于这个过程中所进行的操作严重依赖用户所使用的软件、硬件等，因此并不存在通用的绘图流水线。尽管如此，现今存在着类似Vulkan、OpenGL和DirectX的图形接口，将相似的操作统一起来，并把底层硬件抽象化，以减轻程序员的负担，逐渐成为最为主流的图形接口。&lt;/p&gt;
&lt;p&gt;泛化的来讲，图形管线在概念上一般分为3大阶段：
&lt;img alt=&#34;GP&#34; src=&#34;http://localhost:1313/images/2023/GP.png&#34;&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;应用阶段(Application)&lt;/strong&gt;: 主要在CPU中进行，将所有图元（通常是三角形、线和点）传递到GPU的渲染管线，除此之外还有一些空间细分、碰撞检测、动画、变形都在此阶段进行，这些有助于减少内存使用。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;几何阶段(Geometry)&lt;/strong&gt;: 主要负责对输入的几何数据进行处理和转换。包括顶点着色器（Vertex Shader），它对输入的顶点进行变换和处理，例如执行模型变换、视图变换和投影变换等；还包括曲面细分（Tessellation）和几何着色器（Geometry Shader）等。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;光栅化阶段(Rasterization)&lt;/strong&gt;: 在这个阶段，几何数据被转换为屏幕上的像素片段。它将几何图形（如三角形）转换为像素片段，并确定每个像素片段的位置、颜色和其他属性&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;有很多文章中会分为4个阶段，除了上述的三个阶段外还会有：&lt;/p&gt;
&lt;ol start=&#34;4&#34;&gt;
&lt;li&gt;&lt;strong&gt;像素处理阶段(Pixel)&lt;/strong&gt;: 该阶段对最终的像素进行处理和操作。包括混合（将多个像素的颜色进行混合）、深度测试（根据像素的深度值进行可见性判断）以及模板测试（根据像素的模板值进行特定操作）等&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这是因为以前的老显卡仍然比较接近上述的图形管线。随着对GPU的需求不断增加，限制逐渐被消除，以创造更多的灵活性。现代显卡使用可自由编程、着色器控制的管道，允许直接访问各个处理步骤。为了减轻主处理器的负担，额外的处理步骤已移至管线和GPU。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;不过一般面试的时候你说只有三个阶段的话，面试官可能会觉得你一知半解，恰恰是第四阶段的深度测试、模板测试之类的会是高频考点 XD&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;下面详细展开说一下各阶段的主要内容&lt;/p&gt;
&lt;h3 id=&#34;各阶段主要内容&#34;&gt;各阶段主要内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;应用阶段：&lt;/strong&gt;&lt;br&gt;
在CPU上执行，顾名思义，主要是将软件层面控制的一些工作的内容应用到需要渲染的图元。更通俗的来说就是在GPU绘制之前，告诉它你要画什么。主要内容是：视锥剔除以找到可能需要绘制的图元，生成渲染数据，设置渲染状态，绑定着色器参数，最后CallDraw呼叫GPU进行下一阶段。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;顺带一提，DrawCall是不是很熟悉(Unity优化时常见的术语), 为什么减少DrawCall可以提高游戏性能，原因就是：CPU频繁的调用GPU的绘画，每次都只提交很少的绘画内容，虽然CPU的计算很快，但是CPU频繁的DrawCall使得CPU的效率低下。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;对于GPU而言, GPU的绘画速度远远快于CPU提交的速度，CPU成为了GPU的负担，而使用一些合批手段，尽量让CPU减少提交的次数，提高每次提高的内容，尽量减小CPU进行提交遇到的瓶颈*。这不就是融会贯通了吗。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;几何合阶段：&lt;/strong&gt;
几何阶段在GPU上运行，它处理应用阶段发送的渲染图元，负责大部分的逐三角性和逐顶点操作。几何阶段的一个重要任务就是把顶点坐标变换到屏幕空间中 ，再交给光栅器进行处理。主要有以下几个阶段：顶点着色、投影、裁剪、屏幕映射：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;顶点着色：
计算顶点位置，顶点从模型空间通过MVP转换到了齐次裁剪空间。&lt;em&gt;MVP变换不展开说了(其实是我也懒得看了)，不同图形接口的MVP不太一样。&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;这里还会发生一件很重要的可选项：顶点着色，Unity Shader里面的Vertex Shader就是在这里处理的。这个阶段是完全可控制的，取决于你的Shader是怎么写的。（比如写一个草丛的Shader，顶点位置会周期性的摆动等）
&lt;em&gt;此外，在顶点处理阶段的末尾，还有一些可选的阶段，包括曲面细分(tessellation)、几何着色(geometry shading)和流输出(stream output)，此处不详细描述&lt;/em&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;裁剪阶段：
对部分不在视体内部的图元进行裁剪。这部分是几乎完全由硬件控制的，因此没必要详细描述。
这里的裁剪不同于剔除，剔除是决定图元需不需要渲染，而NDC裁剪在这里是将图元裁剪，这会减少部分像素处理的工作，如下图所示(值得注意的是，真实的渲染管线要复杂得多，这里只是说个大概意思)：&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;img alt=&#34;ndc&#34; src=&#34;http://localhost:1313/images/2023/ndc.png&#34;&gt;&lt;/p&gt;
&lt;ol start=&#34;3&#34;&gt;
&lt;li&gt;屏幕映射：主要将之前步骤得到的坐标映射到屏幕坐标系。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;光栅化阶段：&lt;/strong&gt;
光栅化阶段的目标是找到处于图元(三角形)内部的所有像素，进而将2D坐标顶点转为屏幕上的像素，每个像素附带深度和其他着色信息，它们一并传入pixel。
光栅化阶段分为两个完全由硬件控制的子阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三角形设置(Triangle Setup)(图元装配): 计算出三角形的一些基本数据(如三条边的方程、深度值等)以供三角形遍历阶段使用。&lt;/li&gt;
&lt;li&gt;三角形遍历(Triangle Traversal): 找到哪些像素被三角形所覆盖，并对这些像素的属性值进行插值。通过判断像素的中心采样点是否被三角形覆盖来决定该像素是否要生成片段。通过三角形三个顶点的属性数据，插值得到每个像素的属性值。此外透视校正插值也在这个阶段执行。&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;像素处理阶段：&lt;/strong&gt;
它主要处理光栅化阶段发送过来的在图元内部的片元序列。GPU会对每个片元进行像素操作，如颜色和深度的计算、纹理采样、混合等。主要分为两大阶段：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;像素着色：使用光栅化阶段传递的插值后的数据以及纹理计算像素颜色，进行光照计算和阴影处理，决定屏幕像素的最终颜色
&lt;em&gt;需要注意的是，纹理可以认为是一种独立于”插值“数据的一种资源。由于顶点和像素着色器一般数据都存在更小更快的L1缓存(L1 Cache)中，但纹理存储在更大更慢的L2缓存(L2 Cache)中，因此纹理访问是有延迟的，线程先执行不产生延迟的指令，当遇到产生延迟的指令时，快速切换到其他片元执行其他任务并递归运行。Shader占用的寄存器越多，当内存延迟时，有可能会产生线程被迫等待的情况，这被称作占用率过高&lt;/em&gt;&lt;/li&gt;
&lt;li&gt;测试合并：包括各种测试和混合操作，如裁剪测试、透明测试、模板测试、深度测试以及色彩混合等。经过了测试合并阶段，并存到帧缓冲的像素值，才是最终呈现在屏幕上的图像。&lt;br&gt;
&lt;em&gt;深度测试是在像素着色器之后才执行的。这种做法会导致很多不可见的像素也会执行像素着色器计算，从而浪费了计算资源。为了避免这种浪费，后来的GPU架构采用了Early-Z技术，将深度测试提前到像素着色器之前(如下图所示)。这样一来，Early-Z技术就可以在像素着色器之前剔除很多无效的像素，从而避免它们进入像素着色器，提高了渲染性能&lt;/em&gt;
&lt;em&gt;我们的屏幕显示的就是颜色缓冲区中的颜色值。但是， 为了避免我们看到那些正在进行光栅化的图元，GPU会使用双重缓冲(Double Buffering) 的策略，GPU会交换后置缓冲区和前置缓冲区的内容确保用户只会看到已经渲染好的内容&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3 id=&#34;引擎中的渲染unity3d&#34;&gt;引擎中的渲染(Unity3D)&lt;/h3&gt;
&lt;p&gt;这里会简单介绍一下URP或者HDRP中，延迟渲染(Deferred Rendering)和前向渲染(Forward Rendering)的内容。
首先先介绍一下&lt;strong&gt;渲染路径(rendering Path)&lt;/strong&gt;,渲染路径类似于图形管线，是指在图形渲染中用于生成最终图像的一系列渲染步骤和算法。它决定了渲染引擎在渲染过程中的执行顺序和方式。&lt;/p&gt;
&lt;p&gt;在实时图形渲染中，常见的渲染路径包括&lt;strong&gt;前向渲染&lt;/strong&gt;、&lt;strong&gt;延迟渲染&lt;/strong&gt;和**后向渲染（逆向渲染）**等。每种渲染路径都有不同的优缺点，适用于不同的应用场景。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;前向渲染&lt;/strong&gt;是一种传统的渲染技术，它按照以下步骤进行：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;几何处理：对场景中的几何体进行处理，包括顶点变换、三角形剔除和裁剪等操作。&lt;/li&gt;
&lt;li&gt;光栅化：将几何体转化为像素片段，生成片段的位置、颜色等数据。&lt;/li&gt;
&lt;li&gt;像素处理：对每个像素片段进行处理，包括颜色插值、纹理映射、光照计算和深度测试等操作，最终生成最终的渲染图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：简单直接，适用于小规模场景和少量光源的情况。
局限：当场景中有大量复杂的几何体和光源时，前向渲染需要对每个像素片段进行完整的光照计算，导致性能开销较大。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;延迟渲染&lt;/strong&gt;是一种优化的渲染技术，它将渲染过程分为以下步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;几何处理：与前向渲染相同，对场景中的几何体进行处理。&lt;/li&gt;
&lt;li&gt;几何缓冲：将几何体的属性（位置、法线、颜色等）存储在缓冲区中，而不进行光照计算。&lt;/li&gt;
&lt;li&gt;光照处理：对每个光源进行处理，生成光照的缓冲区，存储光照信息（如漫反射、镜面反射等）。&lt;/li&gt;
&lt;li&gt;合成阶段：通过将几何缓冲和光照缓冲结合，进行最终的像素处理，包括纹理采样、深度测试和混合等操作，生成最终的渲染图像。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;优点：减少了光照计算的开销，适用于复杂场景和大量光源的情况。它可以将光照计算延迟到最后的合成阶段，避免了对每个像素片段进行重复的光照计算，从而提高了性能。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h2 id=&#34;矩阵与变换&#34;&gt;矩阵与变换&lt;/h2&gt;
&lt;h3 id=&#34;mvp&#34;&gt;MVP&lt;/h3&gt;
&lt;p&gt;在计算机图形学中，MVP代表模型-视图-投影（Model-View-Projection），是一种常用的矩阵变换顺序。它是一种用于将三维对象从模型空间（Model Space）转换到屏幕空间（Screen Space）的变换流程。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;模型变换（Model Transformation）：该变换将三维对象从其本地坐标系（模型空间）转换到世界坐标系中的合适位置和方向。这个变换通常包括平移、旋转和缩放等操作。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;视图变换（View Transformation）：该变换将场景从世界坐标系转换到观察者（摄像机）的坐标系。它确定了观察者的位置和方向，使得观察者仿佛位于世界坐标系的原点，朝向z轴负方向。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;投影变换（Projection Transformation）：该变换将观察空间中的三维坐标转换为屏幕空间中的二维坐标，以便最终在屏幕上进行显示。它可以是透视投影（Perspective Projection）或正交投影（Orthographic Projection），具体选择取决于应用需求。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;MVP变换通常通过矩阵乘法来实现。给定一个模型的顶点坐标，它首先应用模型变换，然后是视图变换，最后是投影变换，以得到最终的屏幕坐标。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;有的面试官可能喜欢考察View矩阵和Projection矩阵的推导，如果你是搞游戏引擎的，这应该是必需技能；但是你的工作内容不涉及自己实现这一部分，我认为清楚原理足矣，数学原理你搞得一清二楚，真正到了开发的环境中，最终也是一个引擎提供的现成函数，分清主次，想想引擎如何更好的为你所用更现实一些。&lt;/em&gt;&lt;/p&gt;
&lt;h3 id=&#34;旋转&#34;&gt;旋转&lt;/h3&gt;
&lt;p&gt;欧拉角、矩阵和四元数都是用于表示旋转的方法，它们各自具有不同的特点、优点和缺点。
&lt;strong&gt;欧拉角（Euler Angles）&lt;/strong&gt;：欧拉角使用三个角度值来表示旋转，通常是绕固定的坐标轴进行旋转（例如绕X轴、Y轴和Z轴）。欧拉角易于理解和可视化，但存在万向锁问题（Gimbal Lock），即在某些姿态下，两个旋转轴会合并，导致失去一个自由度。此外，由于旋转顺序的不同会导致不同的结果。BTW，Unity的顺序是ZXY。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;矩阵&lt;/strong&gt;：矩阵可以使用3x3或4x4的矩阵来表示旋转变换。矩阵表示法可以避免万向锁问题，且可以直接应用于坐标变换和向量变换。然而，矩阵运算相对复杂，涉及到矩阵乘法和逆运算，计算量较大，尤其是在大规模场景中。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;四元数（Quaternions）&lt;/strong&gt;：四元数是一种扩展复数的数学工具，用于表示旋转。它通过四个实数构成，包括一个标量和一个三维向量。四元数可以避免万向锁问题，且在插值和连续旋转等方面具有优势。此外，四元数在运算时具有较高的效率，尤其是在插值和球面插值计算中。然而，四元数的数学概念对于初学者来说可能较难理解，且相对于矩阵和欧拉角，其可视化和直观性较差。&lt;/p&gt;
&lt;p&gt;光说概念没什么感觉，举个例子：
我们考虑在三维空间中绕Y轴旋转一个向量。假设我们有一个向量V = [1, 0, 0]，表示沿着X轴的单位向量。我们可以使用一个3x3的旋转矩阵来表示绕Y轴旋转的变换。对于绕Y轴旋转45度的情况:&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;R = | cos(45°)   0   sin(45°) |
    |    0       1       0    |
    | -sin(45°)  0   cos(45°) |

V_rotated = R * V
//结果为：
V_rotated = [0.707, 0, 0.707]
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;使用四元数表示旋转的情况。对于绕Y轴旋转45度的情况，我们可以使用一个四元数来表示旋转变换。旋转角度为45度的绕Y轴旋转的四元数可以表示为&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;q = [cos(45°/2), 0, sin(45°/2), 0]
V_quaternion = [0, 1, 0, 0]
V_rotated_quaternion = q * V_quaternion
//结果为：
V_rotated_quaternion = [0.707, 0, 0.707, 0]
V_rotated = [0.707, 0, 0.707]
&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;齐次坐标与矩阵变换&#34;&gt;齐次坐标与矩阵变换&lt;/h3&gt;
&lt;p&gt;当涉及到矩阵变换时，齐次坐标是一个非常有用的工具。齐次坐标是一种扩展的坐标系统，用于表示三维空间中的点和向量，并且可以方便地进行平移、旋转和缩放等仿射变换操作。&lt;/p&gt;
&lt;p&gt;在齐次坐标中，一个三维点由四个分量表示，通常表示为(x, y, z, w)，其中(x, y, z)是三维空间坐标，w是齐次坐标分量。齐次坐标中的点可以通过将其除以齐次分量w来还原为三维坐标，即(x/w, y/w, z/w)。这种表示方式允许我们使用矩阵来表示一系列的仿射变换操作。&lt;/p&gt;
&lt;p&gt;矩阵变换可以通过将变换矩阵与齐次坐标进行相乘来实现。例如，对于一个平移变换，可以构造一个平移矩阵，然后将其与齐次坐标相乘，即可得到平移后的新坐标。类似地，对于旋转和缩放等变换，也可以构造相应的变换矩阵，并将其与齐次坐标相乘来实现变换。&lt;/p&gt;
&lt;p&gt;在进行矩阵变换时，齐次坐标的第四个分量w通常为1，这样可以确保在进行除法还原为三维坐标时，保持坐标的一致性。同时，齐次坐标还可以表示无穷远点和方向向量，通过将w设置为0或其他非零值来实现。&lt;/p&gt;
&lt;p&gt;总而言之，齐次坐标提供了一种方便的方式来表示和处理矩阵变换，使得平移、旋转和缩放等仿射变换操作可以统一地应用于三维点和向量。通过使用齐次坐标和变换矩阵，我们可以更灵活地进行各种复杂的几何变换。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;平移变换：
假设有一个三维点P(x, y, z)，我们想将其沿着向量T(tx, ty, tz)进行平移。可以构造平移矩阵M，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;M = | 1 0 0 tx |
    | 0 1 0 ty |
    | 0 0 1 tz |
    | 0 0 0  1 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将平移矩阵M与齐次坐标[P, 1]相乘，即可得到平移后的新坐标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;缩放变换：
假设有一个三维点P(x, y, z)，我们想将其沿着不同的轴进行缩放，分别缩放因子为Sx、Sy和Sz。可以构造缩放矩阵M，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;M = | Sx 0 0 0 |
    | 0 Sy 0 0 |
    | 0 0 Sz 0 |
    | 0 0  0 1 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;然后将缩放矩阵M与齐次坐标[P, 1]相乘，即可得到缩放后的新坐标。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;旋转变换：
假设有一个三维点P(x, y, z)，我们想围绕一个单位向量轴A进行旋转，旋转角度为θ。可以构造旋转矩阵M，如下所示：&lt;/p&gt;
&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;M = | R11 R12 R13  0 |
    | R21 R22 R23  0 |
    | R31 R32 R33  0 |
    |   0   0   0  1 |
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;其中，R11、R12、R13等元素是根据旋转轴和旋转角度计算得到的。然后将旋转矩阵M与齐次坐标[P, 1]相乘，即可得到旋转后的新坐标&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&#34;ref&#34;&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://en.wikipedia.org/wiki/Graphics_pipeline&#34;&gt;https://en.wikipedia.org/wiki/Graphics_pipeline&lt;/a&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/430541328&#34;&gt;https://zhuanlan.zhihu.com/p/430541328&lt;/a&gt;
&lt;a href=&#34;https://zhuanlan.zhihu.com/p/627201581&#34;&gt;https://zhuanlan.zhihu.com/p/627201581&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">游戏开发基础 语言基础</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/game-development-basics-language-basics/" />
            <id>http://localhost:1313/tech/game-development-basics-language-basics/</id>
            <updated>2024-08-12T20:20:25&#43;08:00</updated>
            <published>2023-10-07T12:10:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">对基础知识的掌握比较重要，有时候工作或是切实开发几年，脱离了基础知识，等到参加一些注……</summary>
            
                <content type="html">&lt;blockquote&gt;
&lt;p&gt;对基础知识的掌握比较重要，有时候工作或是切实开发几年，脱离了基础知识，等到参加一些注重基础的面试时，啥也不会了。这里会总结一下游戏工程的基石；开发也中很多小小不言的问题，也会聚沙成塔。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;引用类型与值类型&#34;&gt;引用类型与值类型&lt;/h2&gt;
&lt;p&gt;引用类型和值类型&lt;strong&gt;最根本&lt;/strong&gt;的区别就是其在&lt;strong&gt;内存分配&lt;/strong&gt;上的差异：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Stack 栈&lt;/strong&gt;：线程所管理和使用的栈，存放的是值类型和引用类型的地址。
&lt;strong&gt;GC Heap 堆&lt;/strong&gt;：CLR加载到内存后，进程的可用地址空间分配的一段地址空间。引用类型分配在托管堆上，由GC管理。&lt;/p&gt;
&lt;p&gt;举个简单的例子：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;a&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;10&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 变量 a 和它的值 10 都存在 Stack 上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kt&#34;&gt;string&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;b&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;s&#34;&gt;&amp;#34;Hello World&amp;#34;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// 变量 b 存在 Stack 上，其值是托管堆对象地址，这个地址指向字符串 “Hello World”，而这个字符串存在 Heap 上&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;类型的赋值与传递&#34;&gt;类型的赋值与传递&lt;/h3&gt;
&lt;p&gt;值类型的变量赋值：会复制一次值；
引用类型的变量赋值：会复制一次存在 Stack 上的内存地址，指向同一个引用对象的值&lt;/p&gt;
&lt;p&gt;C#程序中进行参数传递的时候，默认按值传递，值类型复制数据本身，形成独立的数据块，引用类型复制引用，指向同一实例。&lt;strong&gt;ref&lt;/strong&gt; 和 &lt;strong&gt;out&lt;/strong&gt; 也可以用作引用传参,它们之间又有什么异同呢? 首先我先讨论一下 ref 和 out 的异同点：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;相同: 都可以使参数按照引用方式传递，这意味着对参数的改变将会引起原始变量的改变,因为它们本质上都是原始数据的引用；&lt;/li&gt;
&lt;li&gt;差异:
&lt;ul&gt;
&lt;li&gt;ref要求参数在使用之前要显式初始化，out要在方法内部初始化;&lt;/li&gt;
&lt;/ul&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// ref: 需要在使用前初始化 number 的值&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;number&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;5&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;SomeFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;number&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// out: 例如Unity经常使用的 TryGetcomponent 函数&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;TryGetcomponent&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ClassA&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;out&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;var&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;
&lt;li&gt;out修饰的参数主要用于返回值，而ref修饰的参数主要用于修改；&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;那么Ref(和out)关键字可以在值类型的传参上实现跟引用类型一样的效果，那么在引用类型参数上加入ref关键字岂不是多此一举吗？答案是否定的，默认传参方式和引用型传参方式毫无疑问是不同的。&lt;/p&gt;
&lt;p&gt;其实默认传参方式和引用型传参方式的不同完全是由进行操作的对象决定的，默认的值传参会复制 值(或引用)然后对这个值(或引用)进行操作；而引用型传参没有复制引用而是对原始变量的引用进行操作的。这也就导致了我上面写的它们的相同点：“&lt;em&gt;对参数的改变将会引起原始变量的改变&lt;/em&gt;”。还是举个例子来说吧：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;10f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;ClassA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;SomeFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 输出的结果为： num1 = 10; person1.num = 30&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 如果使用另一种 引用型传参&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;SomeFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;ref&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;ClassA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;30&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;target&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;person&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kt&#34;&gt;float&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;10f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;ClassA&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;m&#34;&gt;20f&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;n&#34;&gt;SomeFunc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;num1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;person1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 输出的结果为： num1 = 30; person1.num = null&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;为什么会产生这样的结果，还是留给读者们自己思考一下吧。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;深拷贝和浅拷贝&lt;/strong&gt;:&lt;br&gt;
浅拷贝是两个地址指向同一个内存地址, 改变一个对象的值之后,另外一个对象的值也会相应改变,因为它们共用同一个地址指向的值; 深拷贝则是重新新建一个独立的对象,其值指向的地址也是新的,它与原始值之间是相互独立的.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&#34;值与引用类型的八股文&#34;&gt;值与引用类型的八股文&lt;/h3&gt;
&lt;p&gt;其实知道了上面的内容之后，值与引用类型的区别基本上都可以有更深刻的认识或者是可以自行解释了。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;值类型和引用类型的区别&lt;/strong&gt;&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&#34;text-align:center&#34;&gt;&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;值类型&lt;/th&gt;
&lt;th style=&#34;text-align:center&#34;&gt;引用类型&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储方式&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储值本身&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;存储数据值的引用，数据值存在内存堆中&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;效率性能&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;高效&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;效率较低，需要寻址取数据&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;内存回收&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;用完即自动释放&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;由 GC 管理释放&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;语义差异&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复制新对象&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;复制地址引用后传递&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&#34;text-align:center&#34;&gt;类型继承&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;无法派生&lt;/td&gt;
&lt;td style=&#34;text-align:center&#34;&gt;多态和继承等复杂的拓展&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;blockquote&gt;
&lt;p&gt;需要注意的是，C# 中的字符串是引用类型，但它有一些特殊的行为，后面再详细展开。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;strong&gt;结构和类的区别&lt;/strong&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在C#中，结构体（struct）和类（class）是两种表示数据和行为的类型。它们有以下区别：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;语义差异：结构体是值类型（value type），而类是引用类型（reference type）。这意味着当结构体赋值给另一个变量或传递给方法时，会复制整个结构体的值；而类则是通过引用传递，多个变量可以引用同一个对象。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;内存分配：结构体通常分配在栈上，而类通常分配在托管堆（managed heap）上。由于栈上的内存分配和释放比堆上的操作更快，结构体适用于较小的数据类型，对于临时性的数据存储很有用。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;默认构造函数：在类中，如果没有显式定义构造函数，编译器会提供一个默认的无参构造函数。而在结构体中，如果没有显式定义构造函数，那么会有一个默认的无参构造函数，但是结构体也可以定义自己的构造函数。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;继承：类支持继承，可以派生出其他类，形成类的层次结构。而结构体不能继承其他结构体或类，它们只能实现接口。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;可空性：结构体可以通过在其定义中使用 ? 来使其可空，即可为null。而类默认是可为null的，除非显式使用 notnull 或 nonnull 进行标记。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;性能方面的考虑：由于结构体是值类型，它们的拷贝操作可能会导致性能开销。如果结构体较大，频繁进行复制操作可能会影响性能。在这种情况下，使用类可能更加合适。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这两种类型在使用上可能有部分相似的地方，但是实际上在项目里面除了一些特殊的使用需求外，应该没人会把它们混用吧，不过真的有混淆的时候，比如下面这个问题：&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-csharp&#34; data-lang=&#34;csharp&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt; &lt;span class=&#34;c1&#34;&gt;//定义了存放异常状态层数的结构体&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;nc&#34;&gt;StatusInfo&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;kt&#34;&gt;int&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;...&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// others&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;//定义使用了结构体作为value的字典&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kd&#34;&gt;public&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;Dictionary&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;StatusInfo&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;n&#34;&gt;statusDict&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 在某个函数中判断是否存在 Toxin 这个 Status，如果有就让它的异常状态层数 stack +1&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;statusDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;ContainsKey&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Toxin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;n&#34;&gt;statusDict&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Status&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;Toxin&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;].&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;+=&lt;/span&gt;&lt;span class=&#34;m&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;
&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;假设这样一个例子：这是一个用来检查玩家异常状态的逻辑，如果玩家身上的 statusDict 存在 Toxin，就让 statusDict 的值(StatusInfo类型的结构体) 中的 stack + 1.&lt;br&gt;
在不看以下的答案的情况下，想想为什么会出错呢。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;Answer&lt;/strong&gt;： 当StatusInfo定义为Class时，则不会出现错误，那么错误原因是什么也就在于Struct和Class的区别上了。
struct属于值类型，要想改变struct里面元素的值，只能是new一个新的struct。在给字典的结构体值赋值时，实际上是对字典中存储的副本进行操作。由于结构体是值类型，对副本的修改不会影响字典中原始的结构体实例。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在用习惯了引用类型那样的容器之后，确实容易忽略这一点。那为什么类不会报错也很明了:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;类是引用类型，字典存储的是引用，而不是对象的副本。因此，对字典中类的实例进行操作时，实际上是对原始对象进行操作。因此，当你尝试修改字典中存储的结构体值时，编译器会报错。结构体是不可变（immutable）的。如果你想在字典中存储可变的状态信息，可以考虑使用类而不是结构体。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;strong&gt;值类型和引用类型的生命周期&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;值类型在作用域结束后释放; 引用类型由 GC 回收。&lt;br&gt;
还记得吗：值类型存放在 Stack，引用类型分配在 GC Heap上，由 GC 管理。GC 是一个考点，后面会展开讲。&lt;/p&gt;
&lt;hr&gt;
&lt;h2 id=&#34;装箱和拆箱&#34;&gt;装箱和拆箱&lt;/h2&gt;
&lt;p&gt;简单的来说，装箱就是：将值类型对象封装到引用类型对象中，拆箱则是相反的过程：从装箱对象中提取值类型的过程。&lt;/p&gt;
&lt;p&gt;不过根据我们上面写到的知识可以得出：&lt;br&gt;
&lt;strong&gt;装箱&lt;/strong&gt;会创建一个新的堆对象，并将值类型的值复制到堆对象中，使其可以在堆上进行操作。这样做的目的是为了使值类型能够在引用类型的上下文中使用，但同时也会带来一定的性能开销和内存消耗；&lt;strong&gt;拆箱&lt;/strong&gt;会将装箱对象中的值复制到一个值类型变量中，使其可以在栈上进行操作。拆箱操作需要进行类型检查和数据复制，也会带来一定的性能开销。&lt;/p&gt;
&lt;p&gt;装箱和拆箱可以在某些情况下带来方便，但频繁的装箱和拆箱操作可能会对性能造成影响。因此，在开发过程中，我们应该尽量避免不必要的装箱和拆箱操作，尤其是在性能要求较高的场景中。可以通过使用泛型来避免装箱和拆箱，或者使用值类型的特性来提高性能。&lt;/p&gt;
&lt;p&gt;那为什么我们还是无法停止装箱和拆箱呢？拿装箱来说，有些时候我们的程序需要更为泛化的要求的时候就会需要装箱。好吧，这句话本身听起来就挺泛化的，让我们举例来说：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我有一个事件系统，它使用了Callback，有时候会将一些数据也传送出去，但是这些数据的类型有时候是int，有时候是float，有时候是GameObject甚至一些复杂的复合数据，但是我还是希望我能用一个类似泛型一样的方式处理它，所以我们就可以把它装箱成Object，只有需要这些数据的接收者会按照所需的数据进行拆箱来还原数据。&lt;/li&gt;
&lt;li&gt;再比如因为泛型参数限制：在某些情况下，一个函数的参数类型是object，当你需要一个传参数比如Int类型的参数时，就需要装箱(Int-&amp;gt;Object)。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;装箱的优化&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用泛型集合：使用泛型集合类（例如 List&lt;T&gt;、Dictionary&amp;lt;TKey, TValue&amp;gt;）来存储值类型数据，这样可以避免将值类型进行装箱。&lt;/li&gt;
&lt;li&gt;使用值类型特性和方法：值类型（如结构体）可以定义自己的方法和属性，通过直接操作值类型的数据，可以避免拆箱操作。如果可能的话，尽量使用值类型提供的方法来操作值类型的数据，而不是将其拆箱为引用类型。&lt;/li&gt;
&lt;li&gt;使用接口约束：在需要接受值类型作为参数的方法或泛型中，可以使用接口约束来限制类型参数必须是值类型。这样可以确保传递给方法或泛型的参数是值类型，而不需要进行装箱操作。&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt; &lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
        <entry>
            <title type="text">启示录——节奏地牢是如何做出独特玩法的</title>
            <link rel="alternate" type="text/html" href="http://localhost:1313/tech/revelation-how-crypt-of-the-necrodancer-creates-a-unique-gameplay/" />
            <id>http://localhost:1313/tech/revelation-how-crypt-of-the-necrodancer-creates-a-unique-gameplay/</id>
            <updated>2024-08-11T18:18:30&#43;08:00</updated>
            <published>2023-08-19T18:10:00&#43;08:00</published>
            <author>
                    <name>Mingxian</name>
                    <uri>https://yangmingxian.com/</uri>
                    <email>yangmingxian2015@gmail.com</email>
                    </author>
            <rights>在保留本文作者及本文連結的前提下，非商業用途經作者同意后轉載分享。</rights><summary type="html">对于大部分的开发者而言，如何把自己的好想法变成好游戏是很困难的。有时候，站在巨人的肩……</summary>
            
                <content type="html">&lt;p&gt;&lt;img alt=&#34;节奏地牢FT&#34; src=&#34;http://localhost:1313/images/2022/dancer_ft.jpg&#34;&gt;&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;对于大部分的开发者而言，如何把自己的好想法变成好游戏是很困难的。有时候，站在巨人的肩膀上对于独立游戏开发者而言是一条捷径。我尝试了很多独立游戏的点子，其中，节奏地牢可能是我最有感触的。独立、创意和生存之间，节奏地牢把控的很好。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;开发者Ryan Clark的访谈录，想从中找到一些关于节奏检测的灵感，我发现我学到了一些其他方面的东西。Roguelike元素和节奏游戏结合的方式创造了独特的体验，他在自己的博客中详细讲述了这款游戏从创意原型到不断优化调整，创造出独特玩法的过程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;
&lt;p&gt;独立开发者Ryan Clark，他有一些表现和收益很不错的游戏，其中表现最好的《节奏地牢（Crypt of the NecroDancer）》，可以说其第一无二的创意引领了时代，在我大学期间就已经接触过这款游戏了，我坚信一点，那就是：当你玩到某款游戏的时候，那么这款游戏一定是成功的。节奏地牢横扫多个独立游戏奖项，并且在不久前还发布了新的大型DLC，继续续写着独立游戏的辉煌。&lt;/p&gt;
&lt;p&gt;据此前Ryan Clark接受 Gamelook 采访时表示，在《节奏地牢》之前，他的每款游戏研发时间通常是9-12个月，但由于参加业内活动，《节奏地牢》用了2年，经过EA阶段的玩家反馈，他又进行了一些调整和修改，这使得游戏的开发时间增加了一倍。《节奏地牢》的独特之处在于它与大多数的音乐游戏比较，它并不需要玩家精准地踩着点跟节奏；与大多数的RPG游戏相比，它需要踩着音乐节拍才能完成移动和攻击；再加上随机生成的Rogue地牢元素，节奏地牢的把这些特性完美地结合了起来，这也是它能取得成功的内在因素。&lt;/p&gt;
&lt;p&gt;对于大多数的游戏开发者而言，如何把好的想法变成好游戏是困难的，也是痛苦的。因为你会由于某些原因，需要在游戏性和开发成本以及其他方面做出取舍，任何被舍弃的好想法都是独立开发者的遗憾。我也需要一个类似的节奏系统，所以我找到了Ryan Clark的解决方案，他在自己的博客中详细讲述了这款游戏从创意原型到不断优化调整，创造出独特玩法的过程。以下摘自 Gamelook 翻译的博文内容。&lt;/p&gt;
&lt;h2 id=&#34;ryan-clark--独立工作室-brace-yourself-games-创始人&#34;&gt;Ryan Clark —— 独立工作室 Brace Yourself Games 创始人&lt;/h2&gt;
&lt;p&gt;可能很多人知道我是因为2014年发布的《节奏地牢》，但是，我在1984年的时候就已经开始了游戏开发者的旅程，当时父亲用我们性能很低的Apple IIe教我用BASIC编程做一些简单的游戏。随后很多年，我仍旧把游戏研发当作业余爱好，最终在2004年成立了Game Programming Wiki帮助分享自己学到的编程知识。2005年，我终于开始全职做游戏，并且共同创办了Grubby Games，发布了获得过IGF大奖的《Professor Fizzwizzle》，如果你们有过了解，可能还知道我们发布过另外领款拿过IGF奖的《IncrediBots》和《FizzBall》。在2009年，我们把公司卖给了Big Fish Games，2013年的时候我决定从头再来，创办了Brace Yourself Games，创作了《节奏地牢》。&lt;/p&gt;
&lt;h2 id=&#34;一个几乎不需要精准节奏感的玩法&#34;&gt;一个几乎不需要精准节奏感的玩法&lt;/h2&gt;
&lt;p&gt;《节奏地牢》是一个尽可能要求最少韵律感的节奏游戏，我们为什么要和传统的节奏游戏做如此之大的差别呢？&lt;/p&gt;
&lt;h2 id=&#34;做这个游戏的原因是什么&#34;&gt;做这个游戏的原因是什么&lt;/h2&gt;
&lt;p&gt;我最初设计《节奏地牢》的原因是希望做一个带来公平感的地牢Roguelike游戏，这里说的公平指的是《洞穴探险》一样的平等，当你的角色死亡之后，通常只能是因为自己操作失误，你看不到其中的坑，觉得自己下一次可以做的更好。&lt;/p&gt;
&lt;p&gt;只要一款游戏给人的感觉是公平的，那么玩家们遭遇失败之后感觉更多的是挑战而不是沮丧，每次死亡都是因为不知道某些事情，或者就是某些方面的技术还不够，而获得这些必要的知识或者技能，完全取决于玩家自己。&lt;/p&gt;
&lt;p&gt;和这个想法完全相反的是我年轻时候玩过最早的《Rogue》，很多死亡是因为缺乏食物、装备或者只是运气不好。我认为这款游戏里大多数的地牢都是无法通关的。的确，出于某些原因，我仍然玩了很多次，虽然不公平，我仍然热爱这款游戏。但最近我在思考：如果它是公平的，我是不是会更喜欢这款游戏呢？&lt;/p&gt;
&lt;p&gt;所以，我就这么开始了，为了实现‘做一个公平Roguelike游戏’的目标，我最终做了一个限时的回合制游戏，所以这款游戏成为了节奏游戏或者说动作游戏，但不得不提的是，我的初衷是要做一个Roguelike游戏。&lt;/p&gt;
&lt;h2 id=&#34;你是怎么做到的&#34;&gt;你是怎么做到的&lt;/h2&gt;
&lt;p&gt;我认为《洞穴探险》的实时战斗机制是带来公平感的原因之一，它没有《Rogue》里的随即战斗机制，完全是基于技能：你要么主动触发战斗，要么就等着随机遭遇战。但我并不像把《Rogue》里的回合制玩法彻底放弃，所以我进行了综合：我的游戏里仍然有回合制，但做的节奏更快了，我希望这样的设计可以保留两款游戏的经典之处。&lt;/p&gt;
&lt;p&gt;当我做创意原型的时候，在规定时间内的回合制感觉就像是有节奏感的，所以我尝试用Michael Jackson的《颤栗（Thriller）》的节奏玩这个游戏，感觉既紧张刺激又非常有趣，当然，也有一些问题存在。&lt;/p&gt;
&lt;p&gt;首先，我给游戏加入了20%的节奏差，对于一个120bmp的歌曲来说，每个节奏都只有50ms（的时间），20%就意味着你需要在100ms的节奏里作出反应，否则你的移动就会失败，我这么做是因为传统的节奏游戏都会这么做，这些游戏都要求玩家们尽量精确操作。&lt;/p&gt;
&lt;p&gt;但后来我发现有最不精确的时候往往是压力最大的时候，如果一个小boss推到了一堵墙并且对你释放火球，你受惊吓之后意味着下一个操作很难精确，但如果你跟不上节奏，就意味着角色死亡，并且会感到沮丧。所以我尝试改变节奏，后来发现100%节奏差的时候是感觉最好的。我觉得这里模仿节奏游戏是不明智的，大多数的节奏游戏要求你简单地遵循指令、它们的挑战来自于让你精确操作，而在《节奏地牢》里，玩家们的挑战来自于快速的战略战斗本身，让玩家做到精确往往会给他们带来沮丧感。&lt;/p&gt;
&lt;p&gt;其次，我最初的创意原型是让玩家踩着点移动，而游戏里的敌人则在节奏之间进行移动。但我后来觉得这样会让游戏变得可预测，你靠近敌人就进攻，敌人靠近你就会发起攻击，然而不利之处在于，这会让整个游戏看起来与节奏感从视觉上看起来是同步的，你按照节奏移动，而敌人不会。&lt;/p&gt;
&lt;p&gt;这给玩家们想要跟上节奏变得更加困难，然而另一个选择是让玩家和敌人同时移动，但让玩家的动作优先。我原本担心这样做会让玩家困惑，所以一开始并没有尝试。但后来《TowerFall》开发者Matt Thorson尝试了之后坚持让我这么做，事实证明他是对的，调整之后游戏整体觉得好多了，虽然也因此带来了一些小问题，但总的来说，我觉得还是利大于弊。&lt;/p&gt;
&lt;p&gt;第三个问题，出于debug的原因，我记录玩家每次操作的数据，通过看这些日志，我发玩家们会在压力较大的时候不按节奏移动，随后回到了正轨。如之前所说，他们会有时候因为压力出现一次失误，随后变得沮丧。所以我使用了集成工具加入autocalibration系统，如果玩家们比游戏节奏快或者慢了一些，那么游戏就会做出对应的节奏调整，这样玩家们在游戏的时候不会出现miss。&lt;/p&gt;
&lt;p&gt;我的理由是，当玩家们受到节奏信息的时候就会就采取动作；可如果游戏进行当中，你告诉玩家他们错了，这就会带来沮丧感。所以自动校准系统可以给玩家更大的容错率。&lt;/p&gt;
&lt;h2 id=&#34;结果&#34;&gt;结果&lt;/h2&gt;
&lt;p&gt;当我决定打造一个‘公平Roguelike’游戏的时候，并没有预测到会做成《节奏地牢》现在这个样，而且当我决定加入节奏游戏玩法的时候，也没有想到最终去掉了对韵律感的要求。但我对于最终做出来的游戏感到高兴，我认为自己尝试玩很多游戏是调整优化的关键因素，保持开放的设计思路是完成最初意想不到结果的原因。&lt;/p&gt;
&lt;h2 id=&#34;outro&#34;&gt;Outro&lt;/h2&gt;
&lt;h2 id=&#34;ref&#34;&gt;Ref&lt;/h2&gt;
&lt;p&gt;&lt;a href=&#34;https://yangmingxian.com/&#34;&gt;&lt;strong&gt;作者博客：YMX&#39;s Site&lt;/strong&gt;&lt;/a&gt;&lt;br&gt;
&lt;a href=&#34;https://space.bilibili.com/22212765&#34;&gt;&lt;strong&gt;作者B站视频：CyberStreamer&lt;/strong&gt;&lt;/a&gt;&lt;/p&gt;
</content>
            
            
            
                
                
                
                    
                    
                    
                        
                            <category scheme="http://localhost:1313/tech/" term="tech\" label="tech\" />
                        
                    
                
            
            
            
                
                    
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/game-design/" term="Game Design" label="Game Design" />
                            
                        
                            
                            
                            
                                <category scheme="http://localhost:1313/tags/tech/" term="Tech" label="Tech" />
                            
                        
                    
                
            
        </entry>
    
</feed>
